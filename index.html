
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataBridge - Interface API JSON</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            min-height: 600px;
        }

        .left-panel {
            background: #f8f9fa;
            padding: 30px;
            border-right: 1px solid #e9ecef;
        }

        .right-panel {
            padding: 30px;
            background: white;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #4facfe;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .filters-section, .mapping-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e9ecef;
            margin-bottom: 25px;
        }

        .filters-section h3, .mapping-section h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.2rem;
        }

        .mapping-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            position: relative;
            cursor: pointer;
        }

        .mapping-item h4 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 14px;
        }

        .mapping-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .mapping-controls input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .mapping-controls input:disabled {
            background-color: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .mapping-controls label {
            font-size: 11px;
            color: #666;
            margin-bottom: 2px;
            display: block;
        }

        .mapping-remove {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
        }

        .mapping-remove:hover {
            background: #c82333;
        }

        .tree-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 10px;
            background: white;
        }

        .tree-node {
            margin: 2px 0;
            user-select: none;
        }

        .tree-item {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
            cursor: pointer;
        }

        .tree-item:hover {
            background-color: #f8f9fa;
        }

        .tree-item.selected {
            background-color: #e3f2fd;
        }

        .tree-toggle {
            width: 16px;
            height: 16px;
            margin-right: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #666;
            transition: transform 0.2s ease;
        }

        .tree-toggle.expanded {
            transform: rotate(90deg);
        }

        .tree-toggle.leaf {
            width: 16px;
            margin-right: 6px;
        }

        .tree-checkbox {
            margin-right: 8px;
            transform: scale(1.1);
        }

        .tree-label {
            font-size: 14px;
            color: #333;
            flex: 1;
        }

        .tree-children {
            margin-left: 20px;
            border-left: 1px dashed #ddd;
            padding-left: 10px;
        }

        .tree-children.collapsed {
            display: none;
        }

        .tree-icon {
            margin-right: 6px;
            font-size: 12px;
        }

        .tree-icon.folder {
            color: #ffa726;
        }

        .tree-icon.file {
            color: #42a5f5;
        }

        .refresh-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .refresh-controls label {
            margin: 0;
            font-weight: 600;
        }

        .refresh-controls input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .results-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .results-section h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .json-display {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow-x: auto;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }

        .esp32-section {
            background: #e8f5e8;
            border: 2px solid #28a745;
            border-radius: 10px;
            padding: 20px;
        }

        .esp32-section h3 {
            color: #28a745;
            margin-bottom: 15px;
        }

        .esp32-url {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            word-break: break-all;
            margin-bottom: 15px;
        }

        .copy-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .copy-btn:hover {
            background: #218838;
        }

        .status {
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .left-panel {
                border-right: none;
                border-bottom: 1px solid #e9ecef;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .button-group {
                flex-direction: column;
            }
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4facfe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåâ DataBridge <span style="font-size: 0.9rem; font-weight: 700; background: rgba(0,0,0,0.15); padding: 4px 8px; border-radius: 8px; margin-left: 8px;">v0.3.6</span></h1>
            <p>Interface pour r√©cup√©rer et filtrer des donn√©es JSON depuis n'importe quelle API</p>
        </div>

        <div class="main-content">
            <!-- Panneau de gauche : Configuration et filtres -->
            <div class="left-panel">
                <div class="form-group">
                    <label for="apiUrl">URL de l'API JSON :</label>
                    <input type="url" id="apiUrl" placeholder="https://api.exemple.com/data" value="https://api.open-meteo.com/v1/forecast?latitude=46.5312&longitude=0.3322&hourly=temperature_2m,precipitation,weathercode&current_weather=true&timezone=Europe%2FParis">
                    <small style="color: #666; font-size: 12px; margin-top: 5px; display: block;">
                        üå§Ô∏è Exemple : M√©t√©o de Ligug√© via Open-Meteo (gratuit, pas de cl√© API requise)
                    </small>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" onclick="fetchData()">
                        <span id="fetchText">R√©cup√©rer les donn√©es</span>
                        <span id="fetchSpinner" class="loading-spinner" style="display: none;"></span>
                    </button>
                    <button class="btn btn-secondary" onclick="clearData()">Effacer</button>
                </div>

                <div class="refresh-controls">
                    <label for="refreshInterval">Rafra√Æchissement auto (secondes) :</label>
                    <input type="number" id="refreshInterval" value="30" min="5" max="300">
                    <button class="btn btn-success" onclick="toggleAutoRefresh()" id="autoRefreshBtn">
                        D√©marrer
                    </button>
                    <div id="refreshStatus" style="display: none; margin-top: 10px; padding: 8px; background: #e8f5e8; border: 1px solid #28a745; border-radius: 5px; font-size: 12px; color: #155724;">
                        üîÑ Rafra√Æchissement actif - Prochaine mise √† jour dans <span id="countdown">30</span>s
                    </div>
                </div>

                <div class="filters-section" id="filtersSection" style="display: none;">
                    <h3>üìã Filtres disponibles :</h3>
                    <div id="filtersList"></div>
                    <button class="btn btn-secondary" onclick="selectAllFilters()" style="margin-top: 10px;">
                        Tout s√©lectionner
                    </button>
                    <button class="btn btn-secondary" onclick="deselectAllFilters()" style="margin-top: 5px;">
                        Tout d√©s√©lectionner
                    </button>
                </div>

                <div class="mapping-section" id="mappingSection" style="display: none;">
                    <div style="display: flex; align-items: center; margin-bottom: 15px;">
                        <input type="checkbox" id="inputenabled" disabled onchange="toggleMappingSystem()" style="margin-right: 10px; transform: scale(1.3);">
                        <h3 style="margin: 0; flex: 1;">üéØ Mappage de donn√©es :</h3>
                    </div>
                    <p style="font-size: 12px; color: #666; margin-bottom: 15px;">
                        Configurez le mappage des valeurs num√©riques pour adapter les donn√©es √† vos besoins
                    </p>
                    <div id="mappingList"></div>
                </div>
            </div>

            <!-- Panneau de droite : R√©sultats -->
            <div class="right-panel">
                <div id="status"></div>

                <div class="results-section">
                    <h3>üìä R√©sultats filtr√©s :</h3>
                    <div id="jsonDisplay" class="json-display">
                        Aucune donn√©e charg√©e. Veuillez saisir une URL d'API et cliquer sur "R√©cup√©rer les donn√©es".
                    </div>
                </div>

                <div class="esp32-section" id="esp32Section" style="display: none;">
                    <h3>üîå URL ESP32 :</h3>
                    <div id="esp32Url" class="esp32-url"></div>
                    <button class="copy-btn" onclick="openEsp32Url()">Ouvrir l'URL</button>
                    <p style="margin-top: 10px; font-size: 14px; color: #666;">
                        <strong>URL courte g√©n√©r√©e !</strong> Cette URL retourne directement les valeurs filtr√©es en format texte simple (une valeur par ligne). L'ESP32 peut faire une requ√™te GET sur cette URL pour r√©cup√©rer uniquement les valeurs des champs s√©lectionn√©s. L'URL fonctionne depuis n'importe quel appareil connect√©.
                    </p>
                    <div style="margin-top: 16px;">
                        <h3>üîß Exemple Arduino (ESP32) :</h3>
                        <pre id="arduinoCode" class="json-display" style="white-space: pre; overflow:auto;">L'exemple Arduino s'affichera ici apr√®s g√©n√©ration de l'URL.</pre>
                        <button class="copy-btn" style="margin-top:10px;" onclick="copyArduinoCode()">Copier le code Arduino</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentData = null;
        let filteredData = null;
        let autoRefreshInterval = null;
        let isAutoRefreshActive = false;
        let countdownInterval = null;
        let dataMappings = []; // Stockage des mappages de donn√©es
        let mappingSystemEnabled = false; // √âtat global du syst√®me de mappage (d√©sactiv√© par d√©faut)
        let isAdjustingMapping = false; // Emp√™che la r√©g√©n√©ration pendant l'√©dition des seuils

        // Proxy CORS pour contourner les restrictions
        const CORS_PROXY = 'https://api.allorigins.win/raw?url=';

        // Fonction pour r√©cup√©rer les donn√©es depuis l'API
        async function fetchData() {
            const url = document.getElementById('apiUrl').value.trim();
            if (!url) {
                showStatus('Veuillez saisir une URL d\'API', 'error');
                return;
            }

            showStatus('Chargement des donn√©es...', 'loading');
            showFetchSpinner(true);

            try {
                // Utilisation du proxy CORS
                const proxyUrl = CORS_PROXY + encodeURIComponent(url);
                const response = await fetch(proxyUrl);
                
                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }

                const data = await response.json();
                currentData = data;
                
                showStatus('Donn√©es r√©cup√©r√©es avec succ√®s !', 'success');
                generateFilters(data);
                applyFilters();
                
            } catch (error) {
                console.error('Erreur lors de la r√©cup√©ration des donn√©es:', error);
                showStatus(`Erreur: ${error.message}`, 'error');
            } finally {
                showFetchSpinner(false);
            }
        }

        // Fonction pour afficher le spinner de chargement
        function showFetchSpinner(show) {
            const fetchText = document.getElementById('fetchText');
            const fetchSpinner = document.getElementById('fetchSpinner');
            
            if (show) {
                fetchText.style.display = 'none';
                fetchSpinner.style.display = 'inline-block';
            } else {
                fetchText.style.display = 'inline';
                fetchSpinner.style.display = 'none';
            }
        }

        // Fonction pour afficher le statut
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // Fonction pour g√©n√©rer l'arborescence des filtres
        function generateFilters(data) {
            const filtersSection = document.getElementById('filtersSection');
            const filtersList = document.getElementById('filtersList');
            
            if (!data || typeof data !== 'object') {
                filtersSection.style.display = 'none';
                return;
            }

            filtersList.innerHTML = '';
            
            // Cr√©er le conteneur de l'arbre
            const treeContainer = document.createElement('div');
            treeContainer.className = 'tree-container';
            
            // Construire l'arborescence
            const treeStructure = buildTreeStructure(data);
            const treeElement = createTreeElement(treeStructure, '');
            
            treeContainer.appendChild(treeElement);
            filtersList.appendChild(treeContainer);
            filtersSection.style.display = 'block';
            
            // Afficher la section de mappage si des donn√©es num√©riques sont d√©tect√©es
            generateMappingSection(data);
        }

        // Fonction pour g√©n√©rer la section de mappage
        function generateMappingSection(data) {
            const mappingSection = document.getElementById('mappingSection');
            const mappingList = document.getElementById('mappingList');
            
            // Trouver les champs num√©riques s√©lectionn√©s
            const selectedFilters = Array.from(document.querySelectorAll('.tree-checkbox:checked'))
                .map(checkbox => checkbox.value)
                .filter(value => value && value !== '');
            
            const numericSelectedFields = selectedFilters.filter(field => {
                const value = getNestedValue(data, field);
                return typeof value === 'number';
            });
            
            // Afficher uniquement si au moins un champ num√©rique est s√©lectionn√©
            let fieldsToMap = numericSelectedFields;
            if (fieldsToMap.length === 0) {
                mappingSection.style.display = 'none';
                // D√©sactiver le syst√®me de mappage si aucun champ num√©rique n'est s√©lectionn√©
                const globalToggle = document.getElementById('inputenabled');
                if (globalToggle) {
                    globalToggle.checked = false;
                    globalToggle.disabled = true;
                }
                return;
            }
            
            mappingList.innerHTML = '';
            dataMappings = []; // R√©initialiser les mappages
            
            // Cr√©er un mappage par d√©faut pour chaque champ num√©rique
            fieldsToMap.forEach(field => {
                addMappingItem(field);
            });
            
            mappingSection.style.display = 'block';
            // Ne pas forcer l'√©tat: respecter l'√©tat courant de mappingSystemEnabled
            const globalToggle = document.getElementById('inputenabled');
            if (globalToggle) {
                globalToggle.disabled = false;
                globalToggle.checked = !!mappingSystemEnabled;
            }
            // Appliquer l'√©tat courant aux contr√¥les
            syncMappingControlsState();
        }

        // Fonction pour trouver les champs num√©riques
        function findNumericFields(obj, prefix = '') {
            const numericFields = [];
            
            function traverse(current, path = '') {
                if (Array.isArray(current)) {
                    current.forEach((item, index) => {
                        if (typeof item === 'object' && item !== null) {
                            traverse(item, `${path}[${index}]`);
                        } else if (typeof item === 'number') {
                            numericFields.push(`${path}[${index}]`);
                        }
                    });
                } else if (typeof current === 'object' && current !== null) {
                    Object.keys(current).forEach(key => {
                        const fullPath = path ? `${path}.${key}` : key;
                        if (typeof current[key] === 'number') {
                            numericFields.push(fullPath);
                        } else if (typeof current[key] === 'object' && current[key] !== null) {
                            traverse(current[key], fullPath);
                        }
                    });
                }
            }
            
            traverse(obj);
            return numericFields;
        }

        // Fonction pour ajouter un √©l√©ment de mappage
        function addMappingItem(fieldPath) {
            const mappingList = document.getElementById('mappingList');
            const mappingId = `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            const mappingItem = document.createElement('div');
            mappingItem.className = 'mapping-item';
            mappingItem.id = mappingId;
            
            // Obtenir la valeur actuelle pour calculer les seuils par d√©faut
            const currentValue = getNestedValue(currentData, fieldPath);
            const defaultValue = typeof currentValue === 'number' ? currentValue : 0;
            
            mappingItem.innerHTML = `
                <button class="mapping-remove" onclick="removeMapping('${mappingId}')">√ó</button>
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="${mappingId}_enabled" onchange="toggleMapping('${mappingId}')" style="margin-right: 8px; transform: scale(1.2);">
                    <h4 style="margin: 0; flex: 1;">${fieldPath}</h4>
                </div>
                <div class="mapping-controls" id="${mappingId}_controls">
                    <div>
                        <label>Seuil bas (entr√©e)</label>
                        <input type="number" id="${mappingId}_inputLow" value="${Math.floor(defaultValue - 10)}" step="0.1" onchange="updateMappingPreview('${mappingId}', '${fieldPath}')">
                    </div>
                    <div>
                        <label>Seuil haut (entr√©e)</label>
                        <input type="number" id="${mappingId}_inputHigh" value="${Math.floor(defaultValue + 10)}" step="0.1" onchange="updateMappingPreview('${mappingId}', '${fieldPath}')">
                    </div>
                    <div>
                        <label>Seuil bas (sortie)</label>
                        <input type="number" id="${mappingId}_outputLow" value="0" step="1" onchange="updateMappingPreview('${mappingId}', '${fieldPath}')">
                    </div>
                    <div>
                        <label>Seuil haut (sortie)</label>
                        <input type="number" id="${mappingId}_outputHigh" value="100" step="1" onchange="updateMappingPreview('${mappingId}', '${fieldPath}')">
                    </div>
                </div>
                <div style="font-size: 11px; color: #666; margin-top: 5px;">
                    Valeur actuelle: ${currentValue} ‚Üí R√©sultat: <span id="${mappingId}_result">${Math.round(mapValue(currentValue, Math.floor(defaultValue - 10), Math.floor(defaultValue + 10), 0, 100))}</span>
                </div>
            `;
            
            mappingList.appendChild(mappingItem);
            
            // Rendre le "carr√©" cliquable pour activer l'√©dition (focus sur le premier champ)
            mappingItem.addEventListener('click', (event) => {
                const target = event.target;
                // Ne pas interf√©rer avec les interactions natives sur inputs/boutons/labels
                if (target.tagName === 'INPUT' || target.tagName === 'BUTTON' || target.tagName === 'LABEL') return;
                const firstInput = document.getElementById(`${mappingId}_inputLow`);
                if (firstInput && !firstInput.disabled) {
                    firstInput.focus();
                }
            });

            // Ajouter les √©v√©nements de mise √† jour
            const inputs = mappingItem.querySelectorAll('input');
            inputs.forEach(input => {
                input.addEventListener('input', () => updateMappingPreview(mappingId, fieldPath));
            });
            
            // Ajouter le mappage √† la liste
            dataMappings.push({
                id: mappingId,
                field: fieldPath,
                enabled: false,
                inputLow: Math.floor(defaultValue - 10),
                inputHigh: Math.floor(defaultValue + 10),
                outputLow: 0,
                outputHigh: 100
            });

            // Appliquer l'√©tat d'activation courant aux contr√¥les nouvellement ajout√©s
            syncMappingControlsState();
        }

        // Fonction pour ajouter un nouveau mappage
        function addMapping() {
            const fieldPath = prompt('Entrez le chemin du champ √† mapper (ex: temperature, weather.temp):');
            if (fieldPath && fieldPath.trim()) {
                const trimmedPath = fieldPath.trim();
                const value = getNestedValue(currentData, trimmedPath);
                
                if (typeof value === 'number') {
                    addMappingItem(trimmedPath);
                    applyFilters(); // Recalculer avec le nouveau mappage
                } else {
                    alert('Ce champ n\'existe pas ou n\'est pas num√©rique dans les donn√©es actuelles.');
                }
            }
        }


        // Fonction pour supprimer un mappage
        function removeMapping(mappingId) {
            const mappingItem = document.getElementById(mappingId);
            if (mappingItem) {
                mappingItem.remove();
                dataMappings = dataMappings.filter(m => m.id !== mappingId);
                applyFilters(); // Recalculer sans ce mappage
            }
        }

        // Fonction pour mettre √† jour l'aper√ßu du mappage
        function updateMappingPreview(mappingId, fieldPath) {
            const inputLow = parseFloat(document.getElementById(`${mappingId}_inputLow`).value) || 0;
            const inputHigh = parseFloat(document.getElementById(`${mappingId}_inputHigh`).value) || 0;
            const outputLow = parseFloat(document.getElementById(`${mappingId}_outputLow`).value) || 0;
            const outputHigh = parseFloat(document.getElementById(`${mappingId}_outputHigh`).value) || 100;
            
            const currentValue = getNestedValue(currentData, fieldPath);
            const result = Math.round(mapValue(currentValue, inputLow, inputHigh, outputLow, outputHigh));
            
            document.getElementById(`${mappingId}_result`).textContent = result;
            
            // Mettre √† jour le mappage dans la liste
            const mapping = dataMappings.find(m => m.id === mappingId);
            if (mapping) {
                mapping.inputLow = inputLow;
                mapping.inputHigh = inputHigh;
                mapping.outputLow = outputLow;
                mapping.outputHigh = outputHigh;
            }

            // Rafra√Æchir l'affichage des r√©sultats et l'URL sans r√©g√©n√©rer la section de mappage
            if (filteredData) {
                displayResults(filteredData);
            }
            const selectedFilters = Array.from(document.querySelectorAll('.tree-checkbox:checked'))
                .map(checkbox => checkbox.value)
                .filter(value => value && value !== '');
            generateEsp32Url(selectedFilters);

        }

        // Fonction pour mapper une valeur
        function mapValue(value, inputLow, inputHigh, outputLow, outputHigh) {
            if (inputHigh === inputLow) return outputLow;
            return ((value - inputLow) * (outputHigh - outputLow)) / (inputHigh - inputLow) + outputLow;
        }

        // Fonction pour construire la structure d'arbre
        function buildTreeStructure(obj, path = '') {
            const result = {};
            
            if (Array.isArray(obj)) {
                obj.forEach((item, index) => {
                    const itemPath = path ? `${path}[${index}]` : `[${index}]`;
                    if (typeof item === 'object' && item !== null) {
                        result[`[${index}]`] = buildTreeStructure(item, itemPath);
                    } else {
                        result[`[${index}]`] = { _value: item, _path: itemPath };
                    }
                });
            } else if (typeof obj === 'object' && obj !== null) {
                Object.keys(obj).forEach(key => {
                    const keyPath = path ? `${path}.${key}` : key;
                    if (typeof obj[key] === 'object' && obj[key] !== null) {
                        result[key] = buildTreeStructure(obj[key], keyPath);
                    } else {
                        result[key] = { _value: obj[key], _path: keyPath };
                    }
                });
            } else {
                return { _value: obj, _path: path };
            }
            
            return result;
        }

        // Fonction pour cr√©er l'√©l√©ment d'arbre
        function createTreeElement(node, key, level = 0) {
            const container = document.createElement('div');
            container.className = 'tree-node';
            
            if (node._value !== undefined) {
                // C'est une feuille (valeur)
                const item = document.createElement('div');
                item.className = 'tree-item';
                item.innerHTML = `
                    <div class="tree-toggle leaf"></div>
                    <input type="checkbox" class="tree-checkbox" value="${node._path}" onchange="applyFilters()">
                    <span class="tree-icon file">üìÑ</span>
                    <span class="tree-label">${key}: ${typeof node._value === 'string' ? `"${node._value}"` : node._value}</span>
                `;
                container.appendChild(item);
            } else {
                // C'est un n≈ìud (objet/array)
                const hasChildren = Object.keys(node).length > 0;
                const item = document.createElement('div');
                item.className = 'tree-item';
                
                const toggleIcon = hasChildren ? '‚ñ∂' : '';
                const isArrayItem = key.startsWith('[') && key.endsWith(']');
                const folderIcon = isArrayItem ? 'üìÅ' : 'üìÇ';
                
                item.innerHTML = `
                    <div class="tree-toggle ${hasChildren ? '' : 'leaf'}" onclick="toggleTreeNode(this)">
                        ${toggleIcon}
                    </div>
                    <input type="checkbox" class="tree-checkbox" value="${key}" onchange="toggleNodeSelection(this)">
                    <span class="tree-icon folder">${folderIcon}</span>
                    <span class="tree-label">${key}</span>
                `;
                
                container.appendChild(item);
                
                if (hasChildren) {
                    const children = document.createElement('div');
                    children.className = 'tree-children collapsed';
                    
                    Object.keys(node).forEach(childKey => {
                        const childElement = createTreeElement(node[childKey], childKey, level + 1);
                        children.appendChild(childElement);
                    });
                    
                    container.appendChild(children);
                }
            }
            
            return container;
        }

        // Fonction pour basculer l'√©tat d'un n≈ìud d'arbre
        function toggleTreeNode(toggleElement) {
            const treeItem = toggleElement.closest('.tree-item');
            const treeNode = treeItem.closest('.tree-node');
            const children = treeNode.querySelector('.tree-children');
            
            if (children) {
                const isCollapsed = children.classList.contains('collapsed');
                if (isCollapsed) {
                    children.classList.remove('collapsed');
                    toggleElement.classList.add('expanded');
                } else {
                    children.classList.add('collapsed');
                    toggleElement.classList.remove('expanded');
                }
            }
        }

        // Fonction pour g√©rer la s√©lection d'un n≈ìud
        function toggleNodeSelection(checkbox) {
            const treeNode = checkbox.closest('.tree-node');
            const children = treeNode.querySelector('.tree-children');
            
            if (children) {
                const childCheckboxes = children.querySelectorAll('.tree-checkbox');
                childCheckboxes.forEach(childCheckbox => {
                    childCheckbox.checked = checkbox.checked;
                });
            }
            
            applyFilters();
        }

        // Fonction pour extraire tous les champs d'un objet JSON
        function extractFields(obj, prefix = '') {
            const fields = new Set();
            
            function traverse(current, path = '') {
                if (Array.isArray(current)) {
                    current.forEach((item, index) => {
                        if (typeof item === 'object' && item !== null) {
                            traverse(item, `${path}[${index}]`);
                        }
                    });
                } else if (typeof current === 'object' && current !== null) {
                    Object.keys(current).forEach(key => {
                        const fullPath = path ? `${path}.${key}` : key;
                        fields.add(fullPath);
                        traverse(current[key], fullPath);
                    });
                }
            }
            
            traverse(obj);
            return Array.from(fields).sort();
        }

        // Fonction pour appliquer les filtres
        function applyFilters() {
            if (!currentData) return;

            const selectedFilters = Array.from(document.querySelectorAll('.tree-checkbox:checked'))
                .map(checkbox => checkbox.value)
                .filter(value => value && value !== ''); // Filtrer les valeurs vides

            if (selectedFilters.length === 0) {
                filteredData = currentData;
            } else {
                filteredData = filterObjectByFields(currentData, selectedFilters);
            }

            // Mettre √† jour la section de mappage uniquement si on n'est pas en train d'√©diter des seuils
            if (!isAdjustingMapping) {
                generateMappingSection(currentData);
            }

            displayResults(filteredData);
            generateEsp32Url(selectedFilters);
        }

        // Fonction pour filtrer un objet selon les champs s√©lectionn√©s
        function filterObjectByFields(obj, fields) {
            const result = {};
            
            fields.forEach(field => {
                const value = getNestedValue(obj, field);
                if (value !== undefined) {
                    setNestedValue(result, field, value);
                }
            });
            
            return result;
        }

        // Fonction pour obtenir une valeur imbriqu√©e
        function getNestedValue(obj, path) {
            if (!path) return obj;
            
            // G√©rer les chemins avec des indices de tableau
            const parts = path.split(/[\.\[\]]+/).filter(part => part !== '');
            
            return parts.reduce((current, part) => {
                if (current && typeof current === 'object') {
                    // Si c'est un nombre, traiter comme un index de tableau
                    const index = parseInt(part);
                    if (!isNaN(index)) {
                        return current[index];
                    } else {
                        return current[part];
                    }
                }
                return undefined;
            }, obj);
        }

        // Fonction pour d√©finir une valeur imbriqu√©e
        function setNestedValue(obj, path, value) {
            if (!path) return;
            
            const parts = path.split(/[\.\[\]]+/).filter(part => part !== '');
            const lastPart = parts.pop();
            
            let target = parts.reduce((current, part) => {
                if (current && typeof current === 'object') {
                    const index = parseInt(part);
                    if (!isNaN(index)) {
                        if (!Array.isArray(current)) {
                            // Convertir l'objet en array si n√©cessaire
                            const newArray = [];
                            Object.keys(current).forEach(key => {
                                const numKey = parseInt(key);
                                if (!isNaN(numKey)) {
                                    newArray[numKey] = current[key];
                                }
                            });
                            Object.assign(current, newArray);
                        }
                        if (!(index in current)) {
                            current[index] = {};
                        }
                        return current[index];
                    } else {
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        return current[part];
                    }
                }
                return undefined;
            }, obj);
            
            if (target && typeof target === 'object') {
                const index = parseInt(lastPart);
                if (!isNaN(index)) {
                    if (!Array.isArray(target)) {
                        // Convertir l'objet en array si n√©cessaire
                        const newArray = [];
                        Object.keys(target).forEach(key => {
                            const numKey = parseInt(key);
                            if (!isNaN(numKey)) {
                                newArray[numKey] = target[key];
                            }
                        });
                        Object.assign(target, newArray);
                    }
                    target[index] = value;
                } else {
                    target[lastPart] = value;
                }
            }
        }

        // Fonction pour extraire seulement les valeurs en format texte simple
        function extractValuesOnly(obj) {
            const values = [];
            
            function traverse(current, path = '') {
                if (Array.isArray(current)) {
                    current.forEach((item, index) => {
                        if (typeof item === 'object' && item !== null) {
                            traverse(item, `${path}[${index}]`);
                        } else {
                            // Appliquer le mappage si c'est un nombre
                            const mappedValue = applyMapping(item, `${path}[${index}]`);
                            values.push(mappedValue);
                        }
                    });
                } else if (typeof current === 'object' && current !== null) {
                    Object.keys(current).forEach(key => {
                        const fullPath = path ? `${path}.${key}` : key;
                        traverse(current[key], fullPath);
                    });
                } else {
                    // C'est une valeur primitive, appliquer le mappage si c'est un nombre
                    const mappedValue = applyMapping(current, path);
                    values.push(mappedValue);
                }
            }
            
            traverse(obj);
            return values.join('\n');
        }

        // Fonction pour extraire les valeurs sous forme de tableau (pour JSON)
        function extractValuesArray(obj) {
            const values = [];
            function traverse(current, path = '') {
                if (Array.isArray(current)) {
                    current.forEach((item, index) => {
                        if (typeof item === 'object' && item !== null) {
                            traverse(item, `${path}[${index}]`);
                        } else {
                            const mappedValue = applyMapping(item, `${path}[${index}]`);
                            values.push(mappedValue);
                        }
                    });
                } else if (typeof current === 'object' && current !== null) {
                    Object.keys(current).forEach(key => {
                        const fullPath = path ? `${path}.${key}` : key;
                        traverse(current[key], fullPath);
                    });
                } else {
                    const mappedValue = applyMapping(current, path);
                    values.push(mappedValue);
                }
            }
            traverse(obj);
            return values;
        }

        // Fonction pour activer/d√©sactiver un mappage individuel
        function toggleMapping(mappingId) {
            const checkbox = document.getElementById(`${mappingId}_enabled`);
            const controls = document.getElementById(`${mappingId}_controls`);
            const mapping = dataMappings.find(m => m.id === mappingId);
            
            if (mapping) {
                // Ne pas r√©g√©n√©rer la section pendant l'activation/d√©sactivation
                isAdjustingMapping = true;
                mapping.enabled = checkbox.checked;
                
                // Contr√¥les toujours √©ditables
                const inputs = controls.querySelectorAll('input[type="number"]');
                inputs.forEach(input => {
                    input.disabled = false;
                });

                // Mettre √† jour l'aper√ßu imm√©diat
                updateMappingPreview(mappingId, mapping.field);

                // Recalculer les r√©sultats avec l'√©tat activ√©/d√©sactiv√©
                applyFilters();
                isAdjustingMapping = false;
            }
        }

        // Fonction pour activer/d√©sactiver le syst√®me de mappage
        function toggleMappingSystem() {
            const checkbox = document.getElementById('inputenabled');
            mappingSystemEnabled = checkbox.checked;
            
            // Mettre √† jour visuellement tous les mappages
            syncMappingControlsState();
            
            applyFilters(); // Recalculer avec le nouvel √©tat
        }

        // Synchroniser l'√©tat enabled/disabled de tous les contr√¥les de mappage
        function syncMappingControlsState() {
            dataMappings.forEach(mapping => {
                const mappingCheckbox = document.getElementById(`${mapping.id}_enabled`);
                const controls = document.getElementById(`${mapping.id}_controls`);
                if (!mappingCheckbox || !controls) return;

                // Laisser la case √† cocher refl√©ter l'√©tat global, mais ne jamais bloquer les inputs
                mappingCheckbox.disabled = !mappingSystemEnabled;

                const inputs = controls.querySelectorAll('input[type="number"]');
                inputs.forEach(input => {
                    input.disabled = !mappingSystemEnabled;
                });
            });
        }

        // Fonction pour appliquer le mappage √† une valeur
        function applyMapping(value, path) {
            if (typeof value !== 'number' || !mappingSystemEnabled) {
                return value;
            }
            
            // Chercher un mappage activ√© pour ce chemin
            const mapping = dataMappings.find(m => m.field === path && m.enabled);
            if (mapping) {
                const mappedValue = mapValue(value, mapping.inputLow, mapping.inputHigh, mapping.outputLow, mapping.outputHigh);
                return Math.round(mappedValue); // Retourner un entier
            }
            
            return value; // Pas de mappage activ√©, retourner la valeur originale
        }

        // Fonction pour afficher les r√©sultats
        function displayResults(data) {
            const jsonDisplay = document.getElementById('jsonDisplay');
            jsonDisplay.textContent = JSON.stringify(data, null, 2);
        }

        // Fonction utilitaire: encodage base64 s√ªr pour URL
        function encodeToBase64UrlSafe(text) {
            try {
                const b64 = btoa(unescape(encodeURIComponent(text)));
                // URL-safe
                return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
            } catch (e) {
                console.error('Erreur encodage base64:', e);
                return '';
            }
        }

        // Fonction pour encoder l'URL ESP32 (worker) avec filtres et mappages (en clair)
        function encodeShortUrl(apiUrl, filters) {
            const workerBase = 'https://data-bridge.julienrat.workers.dev/';
            const targetUrlParam = `url=${encodeURIComponent(apiUrl)}`;
            const pathsJoined = (filters || []).join(',');
            const pathsParam = pathsJoined ? `paths=${encodeURIComponent(pathsJoined)}` : '';

            // Inclure l'√©tat de mappage et les mappages en clair (lisibles)
            // Lire l'√©tat r√©el de la case si pr√©sente; sinon fallback sur l'√©tat m√©moire
            const mappingCheckbox = document.getElementById('inputenabled');
            const mappingEnabledFlag = mappingCheckbox ? (mappingCheckbox.checked ? '1' : '0') : (mappingSystemEnabled ? '1' : '0');
            const mappingEnabledParam = `mappingEnabled=${mappingEnabledFlag}`;
            const mappingParams = (dataMappings || []).map(m => {
                const tuple = [
                    m.field,
                    m.inputLow,
                    m.inputHigh,
                    m.outputLow,
                    m.outputHigh,
                    m.enabled ? 1 : 0
                ].join(',');
                return `m=${encodeURIComponent(tuple)}`;
            }).join('&');

            const query = [targetUrlParam, pathsParam, mappingEnabledParam, mappingParams]
                .filter(Boolean)
                .join('&');
            return `${workerBase}?${query}`;
        }

        // Fonction pour d√©coder une URL courte
        function decodeShortUrl(encodedData) {
            try {
                const decoded = atob(encodedData);
                return JSON.parse(decoded);
            } catch (error) {
                console.error('Erreur lors du d√©codage de l\'URL courte:', error);
                return null;
            }
        }

        // Fonction pour g√©n√©rer l'URL ESP32 avec donn√©es filtr√©es
        function generateEsp32Url(selectedFilters) {
            const esp32Section = document.getElementById('esp32Section');
            const esp32Url = document.getElementById('esp32Url');
            const arduinoPre = document.getElementById('arduinoCode');
            
            if (selectedFilters.length === 0) {
                esp32Section.style.display = 'none';
                if (arduinoPre) arduinoPre.textContent = "";
                return;
            }

            const baseUrl = document.getElementById('apiUrl').value.trim();
            if (!baseUrl) {
                esp32Section.style.display = 'none';
                return;
            }

            // Cr√©er une URL courte
            const shortUrl = encodeShortUrl(baseUrl, selectedFilters);
            
            esp32Url.textContent = shortUrl;
            esp32Section.style.display = 'block';

            // G√©n√©rer et afficher le code Arduino avec la bonne URL et l'intervalle
            generateArduinoCode(shortUrl, selectedFilters);
        }

        // Fonction pour ouvrir l'URL ESP32 dans un nouvel onglet
        function openEsp32Url() {
            const esp32Url = document.getElementById('esp32Url').textContent;
            if (esp32Url) {
                window.open(esp32Url, '_blank');
            } else {
                showStatus("Aucune URL √† ouvrir", 'error');
            }
        }

        // Fonction pour g√©n√©rer le code Arduino (ESP32)
        function generateArduinoCode(shortUrl, filters) {
            const refreshSeconds = parseInt(document.getElementById('refreshInterval').value) || 30;
            const labels = (filters && filters.length) ? filters : [];
            const labelsEscaped = labels.map(l => l.replace(/\\/g, "\\\\").replace(/"/g, '\\"'));
            const labelsCppArray = labelsEscaped.length > 0 ? `const char* LABELS[] = { "${labelsEscaped.join('", "')}" }\nconst size_t LABELS_COUNT = ${labelsEscaped.length};` : `const char* LABELS[] = {};\nconst size_t LABELS_COUNT = 0;`;
            const code = `// ====== Configuration (variables en haut) ======
// Renseignez votre r√©seau WiFi
const char* WIFI_SSID = "Votre_SSID";      // Nom du r√©seau WiFi
const char* WIFI_PASSWORD = "Votre_MotDePasse"; // Mot de passe du WiFi

// URL de l'endpoint g√©n√©r√© par DataBridge
// Peut renvoyer du JSON (ex: {"response":[...]} ou une valeur) ou du texte simple
const char* ENDPOINT_URL = "${shortUrl}";

// Intervalle de rafra√Æchissement en secondes
int REFRESH_SECONDS = ${refreshSeconds};

// ====== Programme Arduino simple pour ESP32 ======
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h> // Installer "ArduinoJson" via le gestionnaire de biblioth√®ques

// √âtiquettes des valeurs s√©lectionn√©es (dans l'ordre)
${labelsCppArray}

// Taille maximale du tableau de valeurs re√ßu
#ifndef MAX_VALUES
#define MAX_VALUES 32
#endif

// Affiche un tableau de valeurs avec des √©tiquettes si disponibles
void printLabeledArray(JsonArray arr) {
  for (size_t i = 0; i < arr.size(); i++) {
    Serial.print("- "); Serial.print(i); Serial.print(" ("); Serial.print(i < LABELS_COUNT ? LABELS[i] : "valeur"); Serial.print(") : ");
    if (arr[i].is<const char*>()) Serial.println(arr[i].as<const char*>());
    else if (arr[i].is<long>()) Serial.println(arr[i].as<long>());
    else if (arr[i].is<double>()) Serial.println(arr[i].as<double>(), 6);
    else if (arr[i].is<bool>()) Serial.println(arr[i].as<bool>() ? "true" : "false");
    else serializeJson(arr[i], Serial), Serial.println();
  }
}

// Fallback texte simple: affiche chaque ligne avec √©tiquette si possible
void printPlainTextLabeled(const String& text) {
  int index = 0;
  int start = 0;
  while (true) {
    int idx = text.indexOf('\\n', start);
    String line = (idx >= 0) ? text.substring(start, idx) : text.substring(start);
    line.trim();
    if (line.length() > 0) {
      Serial.print("- "); Serial.print(index); Serial.print(" ("); Serial.print(index < LABELS_COUNT ? LABELS[index] : "valeur"); Serial.print(") : ");
      Serial.println(line);
      index++;
    }
    if (idx < 0) break;
    start = idx + 1;
  }
}

// Convertit un JsonVariant (r√©ponse ou valeur) en tableau de floats ordonn√©
// Renvoie true si au moins une valeur a √©t√© extraite
bool parseJsonToValues(JsonVariant root, float* outValues, size_t maxValues, size_t& outCount) {
  outCount = 0;
  if (root.is<JsonArray>()) {
    JsonArray arr = root.as<JsonArray>();
    for (JsonVariant v : arr) {
      if (outCount >= maxValues) break;
      if (v.is<double>()) outValues[outCount++] = static_cast<float>(v.as<double>());
      else if (v.is<long>()) outValues[outCount++] = static_cast<float>(v.as<long>());
      else if (v.is<const char*>()) outValues[outCount++] = String(v.as<const char*>()).toFloat();
      else if (v.is<bool>()) outValues[outCount++] = v.as<bool>() ? 1.0f : 0.0f;
    }
    return outCount > 0;
  }
  if (root.is<JsonObject>()) {
    JsonObject obj = root.as<JsonObject>();
    // Si des labels sont fournis, respecter l'ordre
    if (LABELS_COUNT > 0) {
      for (size_t i = 0; i < LABELS_COUNT && outCount < maxValues; i++) {
        JsonVariant v = obj[LABELS[i]];
        if (v.isNull()) continue;
        if (v.is<double>()) outValues[outCount++] = static_cast<float>(v.as<double>());
        else if (v.is<long>()) outValues[outCount++] = static_cast<float>(v.as<long>());
        else if (v.is<const char*>()) outValues[outCount++] = String(v.as<const char*>()).toFloat();
        else if (v.is<bool>()) outValues[outCount++] = v.as<bool>() ? 1.0f : 0.0f;
      }
    } else {
      // Sinon, it√©rer sur les paires (ordre non garanti)
      for (JsonPair kv : obj) {
        if (outCount >= maxValues) break;
        JsonVariant v = kv.value();
        if (v.is<double>()) outValues[outCount++] = static_cast<float>(v.as<double>());
        else if (v.is<long>()) outValues[outCount++] = static_cast<float>(v.as<long>());
        else if (v.is<const char*>()) outValues[outCount++] = String(v.as<const char*>()).toFloat();
        else if (v.is<bool>()) outValues[outCount++] = v.as<bool>() ? 1.0f : 0.0f;
      }
    }
    return outCount > 0;
  }
  // Valeur simple
  if (root.is<double>()) { outValues[outCount++] = static_cast<float>(root.as<double>()); return true; }
  if (root.is<long>())   { outValues[outCount++] = static_cast<float>(root.as<long>());   return true; }
  if (root.is<const char*>()) { outCount = 1; outValues[0] = String(root.as<const char*>()).toFloat(); return true; }
  if (root.is<bool>()) { outValues[outCount++] = root.as<bool>() ? 1.0f : 0.0f; return true; }
  return false;
}

// D√©code un texte brut (une valeur par ligne) en floats
bool parseTextToValues(const String& text, float* outValues, size_t maxValues, size_t& outCount) {
  outCount = 0;
  int start = 0;
  while (outCount < maxValues) {
    int idx = text.indexOf('\\n', start);
    String line = (idx >= 0) ? text.substring(start, idx) : text.substring(start);
    line.trim();
    if (line.length() > 0) {
      outValues[outCount++] = line.toFloat();
    }
    if (idx < 0) break;
    start = idx + 1;
  }
  return outCount > 0;
}

// R√©cup√®re les valeurs (HTTP GET + parse JSON/texte)
// Retourne true si succ√®s et remplit outValues dans l'ordre des LABELS (si fournis)
bool getMappedValues(float* outValues, size_t maxValues, size_t& outCount, String& error) {
  outCount = 0;
  error = String();
  HTTPClient http;
  http.begin(ENDPOINT_URL);
  int httpCode = http.GET();
  if (httpCode <= 0) {
    error = String("Erreur HTTP: ") + httpCode;
    http.end();
    return false;
  }

  String payload = http.getString();
  http.end();

  // Essayer JSON d'abord
  StaticJsonDocument<4096> doc;
  DeserializationError err = deserializeJson(doc, payload);
  if (!err) {
    JsonVariant root = doc.containsKey("response") ? doc["response"].as<JsonVariant>() : doc.as<JsonVariant>();
    if (parseJsonToValues(root, outValues, maxValues, outCount)) {
      return true;
    }
  }

  // Sinon, parser comme texte
  if (parseTextToValues(payload, outValues, maxValues, outCount)) {
    return true;
  }

  error = "R√©ponse vide ou non exploitable";
  return false;
}

void setup() {
  Serial.begin(115200);
  delay(200);

  // Connexion au WiFi
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connexion au WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print('.');
  }
  Serial.println();
  Serial.print("Connect√©. IP: ");
  Serial.println(WiFi.localIP());
}

void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi d√©connect√©, tentative de reconnexion...");
    WiFi.reconnect();
  } else {
    // R√©cup√©ration simple des valeurs pr√™tes √† l'emploi
    float values[MAX_VALUES];
    size_t count = 0;
    String error;
    if (getMappedValues(values, MAX_VALUES, count, error)) {
      // >>> C'EST ICI QUE VOUS UTILISEZ LES VALEURS RE√áUES <<<
      // Exemple: si vous avez s√©lectionn√© 1 valeur, elle est dans values[0]
      // - Afficher
      Serial.print("Valeurs re√ßues ("), Serial.print(count), Serial.println("):");
      for (size_t i = 0; i < count; i++) {
        Serial.print("  ");
        if (i < LABELS_COUNT) { Serial.print(LABELS[i]); Serial.print(": "); }
        Serial.println(values[i]);
      }
      // - Utiliser: ex. piloter une LED, un servo, envoyer vers MQTT, etc.
      //   float temperature = values[0];
      //   if (temperature > 25.0) { /* allumer ventilateur */ }
    } else {
      Serial.print("Erreur: "); Serial.println(error);
    }
    // Attendre avant la prochaine requ√™te
    delay(REFRESH_SECONDS * 1000);
  }
}
`;

            const pre = document.getElementById('arduinoCode');
            if (pre) {
                pre.textContent = code;
            }
        }

        // Fonction pour copier le code Arduino g√©n√©r√©
        function copyArduinoCode() {
            const pre = document.getElementById('arduinoCode');
            const code = pre ? pre.textContent : '';
            if (!code || code.includes("s'affichera ici")) {
                showStatus('Aucun code √† copier. G√©n√©rez d\'abord une URL.', 'error');
                return;
            }
            navigator.clipboard.writeText(code).then(() => {
                showStatus('Code Arduino copi√© dans le presse-papiers !', 'success');
            }).catch(() => {
                showStatus('Impossible de copier le code automatiquement', 'error');
            });
        }

        // Fonction pour s√©lectionner tous les filtres
        function selectAllFilters() {
            const checkboxes = document.querySelectorAll('.tree-checkbox');
            checkboxes.forEach(checkbox => checkbox.checked = true);
            applyFilters();
        }

        // Fonction pour d√©s√©lectionner tous les filtres
        function deselectAllFilters() {
            const checkboxes = document.querySelectorAll('.tree-checkbox');
            checkboxes.forEach(checkbox => checkbox.checked = false);
            applyFilters();
        }

        // Fonction pour effacer les donn√©es
        function clearData() {
            currentData = null;
            filteredData = null;
            dataMappings = []; // R√©initialiser les mappages
            mappingSystemEnabled = false; // D√©sactiver par d√©faut
            const globalToggle = document.getElementById('inputenabled');
            if (globalToggle) {
                globalToggle.checked = false;
                globalToggle.disabled = true;
            }
            document.getElementById('apiUrl').value = '';
            document.getElementById('jsonDisplay').textContent = 'Aucune donn√©e charg√©e. Veuillez saisir une URL d\'API et cliquer sur "R√©cup√©rer les donn√©es".';
            document.getElementById('filtersSection').style.display = 'none';
            document.getElementById('mappingSection').style.display = 'none';
            document.getElementById('esp32Section').style.display = 'none';
            document.getElementById('status').innerHTML = '';
        }

        // Fonction pour rafra√Æchir les donn√©es en pr√©servant les filtres
        async function refreshDataWithFilters() {
            const url = document.getElementById('apiUrl').value.trim();
            if (!url) {
                showStatus('Aucune URL configur√©e pour le rafra√Æchissement', 'error');
                return;
            }

            // Sauvegarder les filtres actuellement s√©lectionn√©s
            const selectedFilters = Array.from(document.querySelectorAll('.tree-checkbox:checked'))
                .map(checkbox => checkbox.value)
                .filter(value => value && value !== '');

            try {
                // R√©cup√©rer les nouvelles donn√©es
                const proxyUrl = CORS_PROXY + encodeURIComponent(url);
                const response = await fetch(proxyUrl);
                
                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }

                const data = await response.json();
                currentData = data;
                
                // R√©g√©n√©rer les filtres avec les nouvelles donn√©es
                generateFilters(data);
                
                // Restaurer la s√©lection des filtres
                if (selectedFilters.length > 0) {
                    selectedFilters.forEach(filterPath => {
                        const checkbox = document.querySelector(`.tree-checkbox[value="${filterPath}"]`);
                        if (checkbox) {
                            checkbox.checked = true;
                        }
                    });
                }
                
                // Appliquer les filtres avec les nouvelles donn√©es
                applyFilters();
                
                showStatus('Donn√©es rafra√Æchies avec succ√®s !', 'success');
                
            } catch (error) {
                console.error('Erreur lors du rafra√Æchissement:', error);
                showStatus(`Erreur de rafra√Æchissement: ${error.message}`, 'error');
            }
        }

        // Fonction pour d√©marrer le compte √† rebours
        function startCountdown(seconds) {
            const countdownElement = document.getElementById('countdown');
            const refreshStatus = document.getElementById('refreshStatus');
            
            let remaining = seconds;
            countdownElement.textContent = remaining;
            refreshStatus.style.display = 'block';
            
            countdownInterval = setInterval(() => {
                remaining--;
                countdownElement.textContent = remaining;
                
                if (remaining <= 0) {
                    clearInterval(countdownInterval);
                    // Le rafra√Æchissement va se d√©clencher automatiquement
                }
            }, 1000);
        }

        // Fonction pour arr√™ter le compte √† rebours
        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            document.getElementById('refreshStatus').style.display = 'none';
        }

        // Fonction pour basculer le rafra√Æchissement automatique
        function toggleAutoRefresh() {
            const interval = parseInt(document.getElementById('refreshInterval').value);
            const button = document.getElementById('autoRefreshBtn');

            if (isAutoRefreshActive) {
                // Arr√™ter le rafra√Æchissement
                clearInterval(autoRefreshInterval);
                stopCountdown();
                isAutoRefreshActive = false;
                button.textContent = 'D√©marrer';
                button.className = 'btn btn-success';
                showStatus('Rafra√Æchissement automatique arr√™t√©', 'success');
            } else {
                // V√©rifier l'intervalle
                if (interval < 5 || interval > 300) {
                    showStatus('L\'intervalle doit √™tre entre 5 et 300 secondes', 'error');
                    return;
                }
                
                // V√©rifier qu'il y a une URL configur√©e
                const url = document.getElementById('apiUrl').value.trim();
                if (!url) {
                    showStatus('Veuillez d\'abord saisir une URL d\'API', 'error');
                    return;
                }
                
                // D√©marrer le rafra√Æchissement en boucle
                autoRefreshInterval = setInterval(() => {
                    refreshDataWithFilters();
                    startCountdown(interval);
                }, interval * 1000);
                
                isAutoRefreshActive = true;
                button.textContent = 'Arr√™ter';
                button.className = 'btn btn-secondary';
                showStatus(`üîÑ Rafra√Æchissement automatique activ√© (${interval}s)`, 'success');
                
                // Faire un premier rafra√Æchissement imm√©diat et d√©marrer le compte √† rebours
                refreshDataWithFilters();
                startCountdown(interval);
            }
        }

        // Fonction pour g√©rer la touche Entr√©e dans le champ URL
        document.getElementById('apiUrl').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                fetchData();
            }
        });

        // Fonction pour g√©rer les param√®tres URL (mode proxy pour ESP32)
        async function handleProxyMode() {
            const urlParams = new URLSearchParams(window.location.search);
            const shortParam = urlParams.get('s');
            const wantDownload = urlParams.get('download') === '1';
            const proxyUrl = urlParams.get('proxy');
            const filters = urlParams.get('filters');
            
            // Mode URL courte
            if (shortParam) {
                try {
                    // D√©coder l'URL courte
                    const config = decodeShortUrl(shortParam);
                    if (!config) {
                        document.body.innerHTML = 'Erreur: URL courte invalide';
                        return true;
                    }
                    
                    const originalUrl = config.url;
                    const filterList = config.filters;
                    const mappings = config.mappings || [];
                    const mappingEnabled = config.mappingEnabled !== undefined ? config.mappingEnabled : true;
                    
                    // R√©cup√©rer les donn√©es depuis l'API originale
                    const proxyRequestUrl = CORS_PROXY + encodeURIComponent(originalUrl);
                    const response = await fetch(proxyRequestUrl);
                    
                    if (!response.ok) {
                        throw new Error(`Erreur HTTP: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Filtrer les donn√©es selon les filtres demand√©s
                    const filteredData = filterObjectByFields(data, filterList);
                    
                    // Appliquer les mappages temporairement
                    const originalMappings = dataMappings;
                    const originalMappingEnabled = mappingSystemEnabled;
                    dataMappings = mappings;
                    mappingSystemEnabled = mappingEnabled;
                    
                    // Extraire les valeurs en tableau et retourner du JSON
                    const valuesArr = extractValuesArray(filteredData);
                    const payload = valuesArr.length === 1 ? { response: valuesArr[0] } : { response: valuesArr };
                    
                    // Restaurer les mappages originaux
                    dataMappings = originalMappings;
                    mappingSystemEnabled = originalMappingEnabled;
                    
                    // Retourner JSON (texte) ou forcer un t√©l√©chargement
                    const jsonText = JSON.stringify(payload);
                    if (wantDownload) {
                        const blob = new Blob([jsonText], { type: 'application/json' });
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = 'response.json';
                        document.body.appendChild(link);
                        link.click();
                        URL.revokeObjectURL(link.href);
                        return true;
                    } else {
                        document.body.innerText = jsonText;
                    }
                    
                } catch (error) {
                    document.body.innerHTML = `Erreur: ${error.message}`;
                }
                return true; // Mode proxy activ√©
            }
            
            // Mode URL longue (ancien syst√®me pour compatibilit√©)
            if (proxyUrl && filters) {
                try {
                    // D√©coder l'URL originale
                    const originalUrl = decodeURIComponent(proxyUrl);
                    const filterList = filters.split(',');
                    
                    // R√©cup√©rer les donn√©es depuis l'API originale
                    const proxyRequestUrl = CORS_PROXY + encodeURIComponent(originalUrl);
                    const response = await fetch(proxyRequestUrl);
                    
                    if (!response.ok) {
                        throw new Error(`Erreur HTTP: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Filtrer les donn√©es selon les filtres demand√©s
                    const filteredData = filterObjectByFields(data, filterList);
                    
                    // Extraire les valeurs en tableau et retourner du JSON
                    const valuesArr = extractValuesArray(filteredData);
                    const payload = valuesArr.length === 1 ? { response: valuesArr[0] } : { response: valuesArr };
                    const jsonText = JSON.stringify(payload);
                    if (wantDownload) {
                        const blob = new Blob([jsonText], { type: 'application/json' });
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = 'response.json';
                        document.body.appendChild(link);
                        link.click();
                        URL.revokeObjectURL(link.href);
                        return true;
                    } else {
                        document.body.innerText = jsonText;
                    }
                    
                } catch (error) {
                    document.body.innerHTML = `Erreur: ${error.message}`;
                }
                return true; // Mode proxy activ√©
            }
            return false; // Mode normal
        }

        // Initialisation de l'application
        document.addEventListener('DOMContentLoaded', async function() {
            // V√©rifier si on est en mode proxy pour ESP32
            const isProxyMode = await handleProxyMode();
            
            if (!isProxyMode) {
                // Mode normal - interface compl√®te
                // Vous pouvez ajouter une URL d'exemple ici si n√©cessaire
                // document.getElementById('apiUrl').value = 'https://jsonplaceholder.typicode.com/posts/1';
            }
        });
    </script>
</body>
</html>