
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataBridge - Interface API JSON</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            min-height: 600px;
        }

        .left-panel {
            background: #f8f9fa;
            padding: 30px;
            border-right: 1px solid #e9ecef;
        }

        .right-panel {
            padding: 30px;
            background: white;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #4facfe;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .filters-section, .mapping-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e9ecef;
            margin-bottom: 25px;
        }

        .filters-section h3, .mapping-section h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.2rem;
        }

        .mapping-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            position: relative;
            cursor: pointer;
        }

        .mapping-item h4 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 14px;
        }

        .mapping-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        .mapping-controls input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .mapping-controls input:disabled {
            background-color: #f8f9fa;
            color: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .mapping-controls label {
            font-size: 11px;
            color: #666;
            margin-bottom: 2px;
            display: block;
        }

        .mapping-remove {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
        }

        .mapping-remove:hover {
            background: #c82333;
        }

        .tree-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 10px;
            background: white;
        }

        .tree-node {
            margin: 2px 0;
            user-select: none;
        }

        .tree-item {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
            cursor: pointer;
        }

        .tree-item:hover {
            background-color: #f8f9fa;
        }

        .tree-item.selected {
            background-color: #e3f2fd;
        }

        .tree-toggle {
            width: 16px;
            height: 16px;
            margin-right: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #666;
            transition: transform 0.2s ease;
        }

        .tree-toggle.expanded {
            transform: rotate(90deg);
        }

        .tree-toggle.leaf {
            width: 16px;
            margin-right: 6px;
        }

        .tree-checkbox {
            margin-right: 8px;
            transform: scale(1.1);
        }

        .tree-label {
            font-size: 14px;
            color: #333;
            flex: 1;
        }

        .tree-children {
            margin-left: 20px;
            border-left: 1px dashed #ddd;
            padding-left: 10px;
        }

        .tree-children.collapsed {
            display: none;
        }

        .tree-icon {
            margin-right: 6px;
            font-size: 12px;
        }

        .tree-icon.folder {
            color: #ffa726;
        }

        .tree-icon.file {
            color: #42a5f5;
        }

        .refresh-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .refresh-controls label {
            margin: 0;
            font-weight: 600;
        }

        .refresh-controls input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .results-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .results-section h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .json-display {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow-x: auto;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }

        .esp32-section {
            background: #e8f5e8;
            border: 2px solid #28a745;
            border-radius: 10px;
            padding: 20px;
        }

        .esp32-section h3 {
            color: #28a745;
            margin-bottom: 15px;
        }

        .esp32-url {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            word-break: break-all;
            margin-bottom: 15px;
        }

        .copy-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .copy-btn:hover {
            background: #218838;
        }

        .status {
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .left-panel {
                border-right: none;
                border-bottom: 1px solid #e9ecef;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .button-group {
                flex-direction: column;
            }
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #4facfe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🌉 DataBridge <span style="font-size: 0.9rem; font-weight: 700; background: rgba(0,0,0,0.15); padding: 4px 8px; border-radius: 8px; margin-left: 8px;">v0.3.6</span></h1>
            <p>Interface pour récupérer et filtrer des données JSON depuis n'importe quelle API</p>
        </div>

        <div class="main-content">
            <!-- Panneau de gauche : Configuration et filtres -->
            <div class="left-panel">
                <div class="form-group">
                    <label for="apiUrl">URL de l'API JSON :</label>
                    <input type="url" id="apiUrl" placeholder="https://api.exemple.com/data" value="https://api.open-meteo.com/v1/forecast?latitude=46.5312&longitude=0.3322&hourly=temperature_2m,precipitation,weathercode&current_weather=true&timezone=Europe%2FParis">
                    <small style="color: #666; font-size: 12px; margin-top: 5px; display: block;">
                        🌤️ Exemple : Météo de Ligugé via Open-Meteo (gratuit, pas de clé API requise)
                    </small>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" onclick="fetchData()">
                        <span id="fetchText">Récupérer les données</span>
                        <span id="fetchSpinner" class="loading-spinner" style="display: none;"></span>
                    </button>
                    <button class="btn btn-secondary" onclick="clearData()">Effacer</button>
                </div>

                <div class="refresh-controls">
                    <label for="refreshInterval">Rafraîchissement auto (secondes) :</label>
                    <input type="number" id="refreshInterval" value="30" min="5" max="300">
                    <button class="btn btn-success" onclick="toggleAutoRefresh()" id="autoRefreshBtn">
                        Démarrer
                    </button>
                    <div id="refreshStatus" style="display: none; margin-top: 10px; padding: 8px; background: #e8f5e8; border: 1px solid #28a745; border-radius: 5px; font-size: 12px; color: #155724;">
                        🔄 Rafraîchissement actif - Prochaine mise à jour dans <span id="countdown">30</span>s
                    </div>
                </div>

                <div class="filters-section" id="filtersSection" style="display: none;">
                    <h3>📋 Filtres disponibles :</h3>
                    <div id="filtersList"></div>
                    <button class="btn btn-secondary" onclick="selectAllFilters()" style="margin-top: 10px;">
                        Tout sélectionner
                    </button>
                    <button class="btn btn-secondary" onclick="deselectAllFilters()" style="margin-top: 5px;">
                        Tout désélectionner
                    </button>
                </div>

                <div class="mapping-section" id="mappingSection" style="display: none;">
                    <div style="display: flex; align-items: center; margin-bottom: 15px;">
                        <input type="checkbox" id="inputenabled" disabled onchange="toggleMappingSystem()" style="margin-right: 10px; transform: scale(1.3);">
                        <h3 style="margin: 0; flex: 1;">🎯 Mappage de données :</h3>
                    </div>
                    <p style="font-size: 12px; color: #666; margin-bottom: 15px;">
                        Configurez le mappage des valeurs numériques pour adapter les données à vos besoins
                    </p>
                    <div id="mappingList"></div>
                </div>
            </div>

            <!-- Panneau de droite : Résultats -->
            <div class="right-panel">
                <div id="status"></div>

                <div class="results-section">
                    <h3>📊 Résultats filtrés :</h3>
                    <div id="jsonDisplay" class="json-display">
                        Aucune donnée chargée. Veuillez saisir une URL d'API et cliquer sur "Récupérer les données".
                    </div>
                </div>

                <div class="esp32-section" id="esp32Section" style="display: none;">
                    <h3>🔌 URL ESP32 :</h3>
                    <div id="esp32Url" class="esp32-url"></div>
                    <button class="copy-btn" onclick="openEsp32Url()">Ouvrir l'URL</button>
                    <p style="margin-top: 10px; font-size: 14px; color: #666;">
                        <strong>URL courte générée !</strong> Cette URL retourne directement les valeurs filtrées en format texte simple (une valeur par ligne). L'ESP32 peut faire une requête GET sur cette URL pour récupérer uniquement les valeurs des champs sélectionnés. L'URL fonctionne depuis n'importe quel appareil connecté.
                    </p>
                    <div style="margin-top: 16px;">
                        <h3>🔧 Exemple Arduino (ESP32) :</h3>
                        <pre id="arduinoCode" class="json-display" style="white-space: pre; overflow:auto;">L'exemple Arduino s'affichera ici après génération de l'URL.</pre>
                        <button class="copy-btn" style="margin-top:10px;" onclick="copyArduinoCode()">Copier le code Arduino</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentData = null;
        let filteredData = null;
        let autoRefreshInterval = null;
        let isAutoRefreshActive = false;
        let countdownInterval = null;
        let dataMappings = []; // Stockage des mappages de données
        let mappingSystemEnabled = false; // État global du système de mappage (désactivé par défaut)
        let isAdjustingMapping = false; // Empêche la régénération pendant l'édition des seuils

        // Proxy CORS pour contourner les restrictions
        const CORS_PROXY = 'https://api.allorigins.win/raw?url=';

        // Fonction pour récupérer les données depuis l'API
        async function fetchData() {
            const url = document.getElementById('apiUrl').value.trim();
            if (!url) {
                showStatus('Veuillez saisir une URL d\'API', 'error');
                return;
            }

            showStatus('Chargement des données...', 'loading');
            showFetchSpinner(true);

            try {
                // Utilisation du proxy CORS
                const proxyUrl = CORS_PROXY + encodeURIComponent(url);
                const response = await fetch(proxyUrl);
                
                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }

                const data = await response.json();
                currentData = data;
                
                showStatus('Données récupérées avec succès !', 'success');
                generateFilters(data);
                applyFilters();
                
            } catch (error) {
                console.error('Erreur lors de la récupération des données:', error);
                showStatus(`Erreur: ${error.message}`, 'error');
            } finally {
                showFetchSpinner(false);
            }
        }

        // Fonction pour afficher le spinner de chargement
        function showFetchSpinner(show) {
            const fetchText = document.getElementById('fetchText');
            const fetchSpinner = document.getElementById('fetchSpinner');
            
            if (show) {
                fetchText.style.display = 'none';
                fetchSpinner.style.display = 'inline-block';
            } else {
                fetchText.style.display = 'inline';
                fetchSpinner.style.display = 'none';
            }
        }

        // Fonction pour afficher le statut
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        // Fonction pour générer l'arborescence des filtres
        function generateFilters(data) {
            const filtersSection = document.getElementById('filtersSection');
            const filtersList = document.getElementById('filtersList');
            
            if (!data || typeof data !== 'object') {
                filtersSection.style.display = 'none';
                return;
            }

            filtersList.innerHTML = '';
            
            // Créer le conteneur de l'arbre
            const treeContainer = document.createElement('div');
            treeContainer.className = 'tree-container';
            
            // Construire l'arborescence
            const treeStructure = buildTreeStructure(data);
            const treeElement = createTreeElement(treeStructure, '');
            
            treeContainer.appendChild(treeElement);
            filtersList.appendChild(treeContainer);
            filtersSection.style.display = 'block';
            
            // Afficher la section de mappage si des données numériques sont détectées
            generateMappingSection(data);
        }

        // Fonction pour générer la section de mappage
        function generateMappingSection(data) {
            const mappingSection = document.getElementById('mappingSection');
            const mappingList = document.getElementById('mappingList');
            
            // Trouver les champs numériques sélectionnés
            const selectedFilters = Array.from(document.querySelectorAll('.tree-checkbox:checked'))
                .map(checkbox => checkbox.value)
                .filter(value => value && value !== '');
            
            const numericSelectedFields = selectedFilters.filter(field => {
                const value = getNestedValue(data, field);
                return typeof value === 'number';
            });
            
            // Afficher uniquement si au moins un champ numérique est sélectionné
            let fieldsToMap = numericSelectedFields;
            if (fieldsToMap.length === 0) {
                mappingSection.style.display = 'none';
                // Désactiver le système de mappage si aucun champ numérique n'est sélectionné
                const globalToggle = document.getElementById('inputenabled');
                if (globalToggle) {
                    globalToggle.checked = false;
                    globalToggle.disabled = true;
                }
                return;
            }
            
            mappingList.innerHTML = '';
            dataMappings = []; // Réinitialiser les mappages
            
            // Créer un mappage par défaut pour chaque champ numérique
            fieldsToMap.forEach(field => {
                addMappingItem(field);
            });
            
            mappingSection.style.display = 'block';
            // Ne pas forcer l'état: respecter l'état courant de mappingSystemEnabled
            const globalToggle = document.getElementById('inputenabled');
            if (globalToggle) {
                globalToggle.disabled = false;
                globalToggle.checked = !!mappingSystemEnabled;
            }
            // Appliquer l'état courant aux contrôles
            syncMappingControlsState();
        }

        // Fonction pour trouver les champs numériques
        function findNumericFields(obj, prefix = '') {
            const numericFields = [];
            
            function traverse(current, path = '') {
                if (Array.isArray(current)) {
                    current.forEach((item, index) => {
                        if (typeof item === 'object' && item !== null) {
                            traverse(item, `${path}[${index}]`);
                        } else if (typeof item === 'number') {
                            numericFields.push(`${path}[${index}]`);
                        }
                    });
                } else if (typeof current === 'object' && current !== null) {
                    Object.keys(current).forEach(key => {
                        const fullPath = path ? `${path}.${key}` : key;
                        if (typeof current[key] === 'number') {
                            numericFields.push(fullPath);
                        } else if (typeof current[key] === 'object' && current[key] !== null) {
                            traverse(current[key], fullPath);
                        }
                    });
                }
            }
            
            traverse(obj);
            return numericFields;
        }

        // Fonction pour ajouter un élément de mappage
        function addMappingItem(fieldPath) {
            const mappingList = document.getElementById('mappingList');
            const mappingId = `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            const mappingItem = document.createElement('div');
            mappingItem.className = 'mapping-item';
            mappingItem.id = mappingId;
            
            // Obtenir la valeur actuelle pour calculer les seuils par défaut
            const currentValue = getNestedValue(currentData, fieldPath);
            const defaultValue = typeof currentValue === 'number' ? currentValue : 0;
            
            mappingItem.innerHTML = `
                <button class="mapping-remove" onclick="removeMapping('${mappingId}')">×</button>
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="${mappingId}_enabled" onchange="toggleMapping('${mappingId}')" style="margin-right: 8px; transform: scale(1.2);">
                    <h4 style="margin: 0; flex: 1;">${fieldPath}</h4>
                </div>
                <div class="mapping-controls" id="${mappingId}_controls">
                    <div>
                        <label>Seuil bas (entrée)</label>
                        <input type="number" id="${mappingId}_inputLow" value="${Math.floor(defaultValue - 10)}" step="0.1" onchange="updateMappingPreview('${mappingId}', '${fieldPath}')">
                    </div>
                    <div>
                        <label>Seuil haut (entrée)</label>
                        <input type="number" id="${mappingId}_inputHigh" value="${Math.floor(defaultValue + 10)}" step="0.1" onchange="updateMappingPreview('${mappingId}', '${fieldPath}')">
                    </div>
                    <div>
                        <label>Seuil bas (sortie)</label>
                        <input type="number" id="${mappingId}_outputLow" value="0" step="1" onchange="updateMappingPreview('${mappingId}', '${fieldPath}')">
                    </div>
                    <div>
                        <label>Seuil haut (sortie)</label>
                        <input type="number" id="${mappingId}_outputHigh" value="100" step="1" onchange="updateMappingPreview('${mappingId}', '${fieldPath}')">
                    </div>
                </div>
                <div style="font-size: 11px; color: #666; margin-top: 5px;">
                    Valeur actuelle: ${currentValue} → Résultat: <span id="${mappingId}_result">${Math.round(mapValue(currentValue, Math.floor(defaultValue - 10), Math.floor(defaultValue + 10), 0, 100))}</span>
                </div>
            `;
            
            mappingList.appendChild(mappingItem);
            
            // Rendre le "carré" cliquable pour activer l'édition (focus sur le premier champ)
            mappingItem.addEventListener('click', (event) => {
                const target = event.target;
                // Ne pas interférer avec les interactions natives sur inputs/boutons/labels
                if (target.tagName === 'INPUT' || target.tagName === 'BUTTON' || target.tagName === 'LABEL') return;
                const firstInput = document.getElementById(`${mappingId}_inputLow`);
                if (firstInput && !firstInput.disabled) {
                    firstInput.focus();
                }
            });

            // Ajouter les événements de mise à jour
            const inputs = mappingItem.querySelectorAll('input');
            inputs.forEach(input => {
                input.addEventListener('input', () => updateMappingPreview(mappingId, fieldPath));
            });
            
            // Ajouter le mappage à la liste
            dataMappings.push({
                id: mappingId,
                field: fieldPath,
                enabled: false,
                inputLow: Math.floor(defaultValue - 10),
                inputHigh: Math.floor(defaultValue + 10),
                outputLow: 0,
                outputHigh: 100
            });

            // Appliquer l'état d'activation courant aux contrôles nouvellement ajoutés
            syncMappingControlsState();
        }

        // Fonction pour ajouter un nouveau mappage
        function addMapping() {
            const fieldPath = prompt('Entrez le chemin du champ à mapper (ex: temperature, weather.temp):');
            if (fieldPath && fieldPath.trim()) {
                const trimmedPath = fieldPath.trim();
                const value = getNestedValue(currentData, trimmedPath);
                
                if (typeof value === 'number') {
                    addMappingItem(trimmedPath);
                    applyFilters(); // Recalculer avec le nouveau mappage
                } else {
                    alert('Ce champ n\'existe pas ou n\'est pas numérique dans les données actuelles.');
                }
            }
        }


        // Fonction pour supprimer un mappage
        function removeMapping(mappingId) {
            const mappingItem = document.getElementById(mappingId);
            if (mappingItem) {
                mappingItem.remove();
                dataMappings = dataMappings.filter(m => m.id !== mappingId);
                applyFilters(); // Recalculer sans ce mappage
            }
        }

        // Fonction pour mettre à jour l'aperçu du mappage
        function updateMappingPreview(mappingId, fieldPath) {
            const inputLow = parseFloat(document.getElementById(`${mappingId}_inputLow`).value) || 0;
            const inputHigh = parseFloat(document.getElementById(`${mappingId}_inputHigh`).value) || 0;
            const outputLow = parseFloat(document.getElementById(`${mappingId}_outputLow`).value) || 0;
            const outputHigh = parseFloat(document.getElementById(`${mappingId}_outputHigh`).value) || 100;
            
            const currentValue = getNestedValue(currentData, fieldPath);
            const result = Math.round(mapValue(currentValue, inputLow, inputHigh, outputLow, outputHigh));
            
            document.getElementById(`${mappingId}_result`).textContent = result;
            
            // Mettre à jour le mappage dans la liste
            const mapping = dataMappings.find(m => m.id === mappingId);
            if (mapping) {
                mapping.inputLow = inputLow;
                mapping.inputHigh = inputHigh;
                mapping.outputLow = outputLow;
                mapping.outputHigh = outputHigh;
            }

            // Rafraîchir l'affichage des résultats et l'URL sans régénérer la section de mappage
            if (filteredData) {
                displayResults(filteredData);
            }
            const selectedFilters = Array.from(document.querySelectorAll('.tree-checkbox:checked'))
                .map(checkbox => checkbox.value)
                .filter(value => value && value !== '');
            generateEsp32Url(selectedFilters);

        }

        // Fonction pour mapper une valeur
        function mapValue(value, inputLow, inputHigh, outputLow, outputHigh) {
            if (inputHigh === inputLow) return outputLow;
            return ((value - inputLow) * (outputHigh - outputLow)) / (inputHigh - inputLow) + outputLow;
        }

        // Fonction pour construire la structure d'arbre
        function buildTreeStructure(obj, path = '') {
            const result = {};
            
            if (Array.isArray(obj)) {
                obj.forEach((item, index) => {
                    const itemPath = path ? `${path}[${index}]` : `[${index}]`;
                    if (typeof item === 'object' && item !== null) {
                        result[`[${index}]`] = buildTreeStructure(item, itemPath);
                    } else {
                        result[`[${index}]`] = { _value: item, _path: itemPath };
                    }
                });
            } else if (typeof obj === 'object' && obj !== null) {
                Object.keys(obj).forEach(key => {
                    const keyPath = path ? `${path}.${key}` : key;
                    if (typeof obj[key] === 'object' && obj[key] !== null) {
                        result[key] = buildTreeStructure(obj[key], keyPath);
                    } else {
                        result[key] = { _value: obj[key], _path: keyPath };
                    }
                });
            } else {
                return { _value: obj, _path: path };
            }
            
            return result;
        }

        // Fonction pour créer l'élément d'arbre
        function createTreeElement(node, key, level = 0) {
            const container = document.createElement('div');
            container.className = 'tree-node';
            
            if (node._value !== undefined) {
                // C'est une feuille (valeur)
                const item = document.createElement('div');
                item.className = 'tree-item';
                item.innerHTML = `
                    <div class="tree-toggle leaf"></div>
                    <input type="checkbox" class="tree-checkbox" value="${node._path}" onchange="applyFilters()">
                    <span class="tree-icon file">📄</span>
                    <span class="tree-label">${key}: ${typeof node._value === 'string' ? `"${node._value}"` : node._value}</span>
                `;
                container.appendChild(item);
            } else {
                // C'est un nœud (objet/array)
                const hasChildren = Object.keys(node).length > 0;
                const item = document.createElement('div');
                item.className = 'tree-item';
                
                const toggleIcon = hasChildren ? '▶' : '';
                const isArrayItem = key.startsWith('[') && key.endsWith(']');
                const folderIcon = isArrayItem ? '📁' : '📂';
                
                item.innerHTML = `
                    <div class="tree-toggle ${hasChildren ? '' : 'leaf'}" onclick="toggleTreeNode(this)">
                        ${toggleIcon}
                    </div>
                    <input type="checkbox" class="tree-checkbox" value="${key}" onchange="toggleNodeSelection(this)">
                    <span class="tree-icon folder">${folderIcon}</span>
                    <span class="tree-label">${key}</span>
                `;
                
                container.appendChild(item);
                
                if (hasChildren) {
                    const children = document.createElement('div');
                    children.className = 'tree-children collapsed';
                    
                    Object.keys(node).forEach(childKey => {
                        const childElement = createTreeElement(node[childKey], childKey, level + 1);
                        children.appendChild(childElement);
                    });
                    
                    container.appendChild(children);
                }
            }
            
            return container;
        }

        // Fonction pour basculer l'état d'un nœud d'arbre
        function toggleTreeNode(toggleElement) {
            const treeItem = toggleElement.closest('.tree-item');
            const treeNode = treeItem.closest('.tree-node');
            const children = treeNode.querySelector('.tree-children');
            
            if (children) {
                const isCollapsed = children.classList.contains('collapsed');
                if (isCollapsed) {
                    children.classList.remove('collapsed');
                    toggleElement.classList.add('expanded');
                } else {
                    children.classList.add('collapsed');
                    toggleElement.classList.remove('expanded');
                }
            }
        }

        // Fonction pour gérer la sélection d'un nœud
        function toggleNodeSelection(checkbox) {
            const treeNode = checkbox.closest('.tree-node');
            const children = treeNode.querySelector('.tree-children');
            
            if (children) {
                const childCheckboxes = children.querySelectorAll('.tree-checkbox');
                childCheckboxes.forEach(childCheckbox => {
                    childCheckbox.checked = checkbox.checked;
                });
            }
            
            applyFilters();
        }

        // Fonction pour extraire tous les champs d'un objet JSON
        function extractFields(obj, prefix = '') {
            const fields = new Set();
            
            function traverse(current, path = '') {
                if (Array.isArray(current)) {
                    current.forEach((item, index) => {
                        if (typeof item === 'object' && item !== null) {
                            traverse(item, `${path}[${index}]`);
                        }
                    });
                } else if (typeof current === 'object' && current !== null) {
                    Object.keys(current).forEach(key => {
                        const fullPath = path ? `${path}.${key}` : key;
                        fields.add(fullPath);
                        traverse(current[key], fullPath);
                    });
                }
            }
            
            traverse(obj);
            return Array.from(fields).sort();
        }

        // Fonction pour appliquer les filtres
        function applyFilters() {
            if (!currentData) return;

            const selectedFilters = Array.from(document.querySelectorAll('.tree-checkbox:checked'))
                .map(checkbox => checkbox.value)
                .filter(value => value && value !== ''); // Filtrer les valeurs vides

            if (selectedFilters.length === 0) {
                filteredData = currentData;
            } else {
                filteredData = filterObjectByFields(currentData, selectedFilters);
            }

            // Mettre à jour la section de mappage uniquement si on n'est pas en train d'éditer des seuils
            if (!isAdjustingMapping) {
                generateMappingSection(currentData);
            }

            displayResults(filteredData);
            generateEsp32Url(selectedFilters);
        }

        // Fonction pour filtrer un objet selon les champs sélectionnés
        function filterObjectByFields(obj, fields) {
            const result = {};
            
            fields.forEach(field => {
                const value = getNestedValue(obj, field);
                if (value !== undefined) {
                    setNestedValue(result, field, value);
                }
            });
            
            return result;
        }

        // Fonction pour obtenir une valeur imbriquée
        function getNestedValue(obj, path) {
            if (!path) return obj;
            
            // Gérer les chemins avec des indices de tableau
            const parts = path.split(/[\.\[\]]+/).filter(part => part !== '');
            
            return parts.reduce((current, part) => {
                if (current && typeof current === 'object') {
                    // Si c'est un nombre, traiter comme un index de tableau
                    const index = parseInt(part);
                    if (!isNaN(index)) {
                        return current[index];
                    } else {
                        return current[part];
                    }
                }
                return undefined;
            }, obj);
        }

        // Fonction pour définir une valeur imbriquée
        function setNestedValue(obj, path, value) {
            if (!path) return;
            
            const parts = path.split(/[\.\[\]]+/).filter(part => part !== '');
            const lastPart = parts.pop();
            
            let target = parts.reduce((current, part) => {
                if (current && typeof current === 'object') {
                    const index = parseInt(part);
                    if (!isNaN(index)) {
                        if (!Array.isArray(current)) {
                            // Convertir l'objet en array si nécessaire
                            const newArray = [];
                            Object.keys(current).forEach(key => {
                                const numKey = parseInt(key);
                                if (!isNaN(numKey)) {
                                    newArray[numKey] = current[key];
                                }
                            });
                            Object.assign(current, newArray);
                        }
                        if (!(index in current)) {
                            current[index] = {};
                        }
                        return current[index];
                    } else {
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        return current[part];
                    }
                }
                return undefined;
            }, obj);
            
            if (target && typeof target === 'object') {
                const index = parseInt(lastPart);
                if (!isNaN(index)) {
                    if (!Array.isArray(target)) {
                        // Convertir l'objet en array si nécessaire
                        const newArray = [];
                        Object.keys(target).forEach(key => {
                            const numKey = parseInt(key);
                            if (!isNaN(numKey)) {
                                newArray[numKey] = target[key];
                            }
                        });
                        Object.assign(target, newArray);
                    }
                    target[index] = value;
                } else {
                    target[lastPart] = value;
                }
            }
        }

        // Fonction pour extraire seulement les valeurs en format texte simple
        function extractValuesOnly(obj) {
            const values = [];
            
            function traverse(current, path = '') {
                if (Array.isArray(current)) {
                    current.forEach((item, index) => {
                        if (typeof item === 'object' && item !== null) {
                            traverse(item, `${path}[${index}]`);
                        } else {
                            // Appliquer le mappage si c'est un nombre
                            const mappedValue = applyMapping(item, `${path}[${index}]`);
                            values.push(mappedValue);
                        }
                    });
                } else if (typeof current === 'object' && current !== null) {
                    Object.keys(current).forEach(key => {
                        const fullPath = path ? `${path}.${key}` : key;
                        traverse(current[key], fullPath);
                    });
                } else {
                    // C'est une valeur primitive, appliquer le mappage si c'est un nombre
                    const mappedValue = applyMapping(current, path);
                    values.push(mappedValue);
                }
            }
            
            traverse(obj);
            return values.join('\n');
        }

        // Fonction pour extraire les valeurs sous forme de tableau (pour JSON)
        function extractValuesArray(obj) {
            const values = [];
            function traverse(current, path = '') {
                if (Array.isArray(current)) {
                    current.forEach((item, index) => {
                        if (typeof item === 'object' && item !== null) {
                            traverse(item, `${path}[${index}]`);
                        } else {
                            const mappedValue = applyMapping(item, `${path}[${index}]`);
                            values.push(mappedValue);
                        }
                    });
                } else if (typeof current === 'object' && current !== null) {
                    Object.keys(current).forEach(key => {
                        const fullPath = path ? `${path}.${key}` : key;
                        traverse(current[key], fullPath);
                    });
                } else {
                    const mappedValue = applyMapping(current, path);
                    values.push(mappedValue);
                }
            }
            traverse(obj);
            return values;
        }

        // Fonction pour activer/désactiver un mappage individuel
        function toggleMapping(mappingId) {
            const checkbox = document.getElementById(`${mappingId}_enabled`);
            const controls = document.getElementById(`${mappingId}_controls`);
            const mapping = dataMappings.find(m => m.id === mappingId);
            
            if (mapping) {
                // Ne pas régénérer la section pendant l'activation/désactivation
                isAdjustingMapping = true;
                mapping.enabled = checkbox.checked;
                
                // Contrôles toujours éditables
                const inputs = controls.querySelectorAll('input[type="number"]');
                inputs.forEach(input => {
                    input.disabled = false;
                });

                // Mettre à jour l'aperçu immédiat
                updateMappingPreview(mappingId, mapping.field);

                // Recalculer les résultats avec l'état activé/désactivé
                applyFilters();
                isAdjustingMapping = false;
            }
        }

        // Fonction pour activer/désactiver le système de mappage
        function toggleMappingSystem() {
            const checkbox = document.getElementById('inputenabled');
            mappingSystemEnabled = checkbox.checked;
            
            // Mettre à jour visuellement tous les mappages
            syncMappingControlsState();
            
            applyFilters(); // Recalculer avec le nouvel état
        }

        // Synchroniser l'état enabled/disabled de tous les contrôles de mappage
        function syncMappingControlsState() {
            dataMappings.forEach(mapping => {
                const mappingCheckbox = document.getElementById(`${mapping.id}_enabled`);
                const controls = document.getElementById(`${mapping.id}_controls`);
                if (!mappingCheckbox || !controls) return;

                // Laisser la case à cocher refléter l'état global, mais ne jamais bloquer les inputs
                mappingCheckbox.disabled = !mappingSystemEnabled;

                const inputs = controls.querySelectorAll('input[type="number"]');
                inputs.forEach(input => {
                    input.disabled = !mappingSystemEnabled;
                });
            });
        }

        // Fonction pour appliquer le mappage à une valeur
        function applyMapping(value, path) {
            if (typeof value !== 'number' || !mappingSystemEnabled) {
                return value;
            }
            
            // Chercher un mappage activé pour ce chemin
            const mapping = dataMappings.find(m => m.field === path && m.enabled);
            if (mapping) {
                const mappedValue = mapValue(value, mapping.inputLow, mapping.inputHigh, mapping.outputLow, mapping.outputHigh);
                return Math.round(mappedValue); // Retourner un entier
            }
            
            return value; // Pas de mappage activé, retourner la valeur originale
        }

        // Fonction pour afficher les résultats
        function displayResults(data) {
            const jsonDisplay = document.getElementById('jsonDisplay');
            jsonDisplay.textContent = JSON.stringify(data, null, 2);
        }

        // Fonction utilitaire: encodage base64 sûr pour URL
        function encodeToBase64UrlSafe(text) {
            try {
                const b64 = btoa(unescape(encodeURIComponent(text)));
                // URL-safe
                return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
            } catch (e) {
                console.error('Erreur encodage base64:', e);
                return '';
            }
        }

        // Fonction pour encoder l'URL ESP32 (worker) avec filtres et mappages (en clair)
        function encodeShortUrl(apiUrl, filters) {
            const workerBase = 'https://data-bridge.julienrat.workers.dev/';
            const targetUrlParam = `url=${encodeURIComponent(apiUrl)}`;
            const pathsJoined = (filters || []).join(',');
            const pathsParam = pathsJoined ? `paths=${encodeURIComponent(pathsJoined)}` : '';

            // Inclure l'état de mappage et les mappages en clair (lisibles)
            // Lire l'état réel de la case si présente; sinon fallback sur l'état mémoire
            const mappingCheckbox = document.getElementById('inputenabled');
            const mappingEnabledFlag = mappingCheckbox ? (mappingCheckbox.checked ? '1' : '0') : (mappingSystemEnabled ? '1' : '0');
            const mappingEnabledParam = `mappingEnabled=${mappingEnabledFlag}`;
            const mappingParams = (dataMappings || []).map(m => {
                const tuple = [
                    m.field,
                    m.inputLow,
                    m.inputHigh,
                    m.outputLow,
                    m.outputHigh,
                    m.enabled ? 1 : 0
                ].join(',');
                return `m=${encodeURIComponent(tuple)}`;
            }).join('&');

            const query = [targetUrlParam, pathsParam, mappingEnabledParam, mappingParams]
                .filter(Boolean)
                .join('&');
            return `${workerBase}?${query}`;
        }

        // Fonction pour décoder une URL courte
        function decodeShortUrl(encodedData) {
            try {
                const decoded = atob(encodedData);
                return JSON.parse(decoded);
            } catch (error) {
                console.error('Erreur lors du décodage de l\'URL courte:', error);
                return null;
            }
        }

        // Fonction pour générer l'URL ESP32 avec données filtrées
        function generateEsp32Url(selectedFilters) {
            const esp32Section = document.getElementById('esp32Section');
            const esp32Url = document.getElementById('esp32Url');
            const arduinoPre = document.getElementById('arduinoCode');
            
            if (selectedFilters.length === 0) {
                esp32Section.style.display = 'none';
                if (arduinoPre) arduinoPre.textContent = "";
                return;
            }

            const baseUrl = document.getElementById('apiUrl').value.trim();
            if (!baseUrl) {
                esp32Section.style.display = 'none';
                return;
            }

            // Créer une URL courte
            const shortUrl = encodeShortUrl(baseUrl, selectedFilters);
            
            esp32Url.textContent = shortUrl;
            esp32Section.style.display = 'block';

            // Générer et afficher le code Arduino avec la bonne URL et l'intervalle
            generateArduinoCode(shortUrl, selectedFilters);
        }

        // Fonction pour ouvrir l'URL ESP32 dans un nouvel onglet
        function openEsp32Url() {
            const esp32Url = document.getElementById('esp32Url').textContent;
            if (esp32Url) {
                window.open(esp32Url, '_blank');
            } else {
                showStatus("Aucune URL à ouvrir", 'error');
            }
        }

        // Fonction pour générer le code Arduino (ESP32)
        function generateArduinoCode(shortUrl, filters) {
            const refreshSeconds = parseInt(document.getElementById('refreshInterval').value) || 30;
            const labels = (filters && filters.length) ? filters : [];
            const labelsEscaped = labels.map(l => l.replace(/\\/g, "\\\\").replace(/"/g, '\\"'));
            const labelsCppArray = labelsEscaped.length > 0 ? `const char* LABELS[] = { "${labelsEscaped.join('", "')}" }\nconst size_t LABELS_COUNT = ${labelsEscaped.length};` : `const char* LABELS[] = {};\nconst size_t LABELS_COUNT = 0;`;
            const code = `// ====== Configuration (variables en haut) ======
// Renseignez votre réseau WiFi
const char* WIFI_SSID = "Votre_SSID";      // Nom du réseau WiFi
const char* WIFI_PASSWORD = "Votre_MotDePasse"; // Mot de passe du WiFi

// URL de l'endpoint généré par DataBridge
// Peut renvoyer du JSON (ex: {"response":[...]} ou une valeur) ou du texte simple
const char* ENDPOINT_URL = "${shortUrl}";

// Intervalle de rafraîchissement en secondes
int REFRESH_SECONDS = ${refreshSeconds};

// ====== Programme Arduino simple pour ESP32 ======
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h> // Installer "ArduinoJson" via le gestionnaire de bibliothèques

// Étiquettes des valeurs sélectionnées (dans l'ordre)
${labelsCppArray}

// Taille maximale du tableau de valeurs reçu
#ifndef MAX_VALUES
#define MAX_VALUES 32
#endif

// Affiche un tableau de valeurs avec des étiquettes si disponibles
void printLabeledArray(JsonArray arr) {
  for (size_t i = 0; i < arr.size(); i++) {
    Serial.print("- "); Serial.print(i); Serial.print(" ("); Serial.print(i < LABELS_COUNT ? LABELS[i] : "valeur"); Serial.print(") : ");
    if (arr[i].is<const char*>()) Serial.println(arr[i].as<const char*>());
    else if (arr[i].is<long>()) Serial.println(arr[i].as<long>());
    else if (arr[i].is<double>()) Serial.println(arr[i].as<double>(), 6);
    else if (arr[i].is<bool>()) Serial.println(arr[i].as<bool>() ? "true" : "false");
    else serializeJson(arr[i], Serial), Serial.println();
  }
}

// Fallback texte simple: affiche chaque ligne avec étiquette si possible
void printPlainTextLabeled(const String& text) {
  int index = 0;
  int start = 0;
  while (true) {
    int idx = text.indexOf('\\n', start);
    String line = (idx >= 0) ? text.substring(start, idx) : text.substring(start);
    line.trim();
    if (line.length() > 0) {
      Serial.print("- "); Serial.print(index); Serial.print(" ("); Serial.print(index < LABELS_COUNT ? LABELS[index] : "valeur"); Serial.print(") : ");
      Serial.println(line);
      index++;
    }
    if (idx < 0) break;
    start = idx + 1;
  }
}

// Convertit un JsonVariant (réponse ou valeur) en tableau de floats ordonné
// Renvoie true si au moins une valeur a été extraite
bool parseJsonToValues(JsonVariant root, float* outValues, size_t maxValues, size_t& outCount) {
  outCount = 0;
  if (root.is<JsonArray>()) {
    JsonArray arr = root.as<JsonArray>();
    for (JsonVariant v : arr) {
      if (outCount >= maxValues) break;
      if (v.is<double>()) outValues[outCount++] = static_cast<float>(v.as<double>());
      else if (v.is<long>()) outValues[outCount++] = static_cast<float>(v.as<long>());
      else if (v.is<const char*>()) outValues[outCount++] = String(v.as<const char*>()).toFloat();
      else if (v.is<bool>()) outValues[outCount++] = v.as<bool>() ? 1.0f : 0.0f;
    }
    return outCount > 0;
  }
  if (root.is<JsonObject>()) {
    JsonObject obj = root.as<JsonObject>();
    // Si des labels sont fournis, respecter l'ordre
    if (LABELS_COUNT > 0) {
      for (size_t i = 0; i < LABELS_COUNT && outCount < maxValues; i++) {
        JsonVariant v = obj[LABELS[i]];
        if (v.isNull()) continue;
        if (v.is<double>()) outValues[outCount++] = static_cast<float>(v.as<double>());
        else if (v.is<long>()) outValues[outCount++] = static_cast<float>(v.as<long>());
        else if (v.is<const char*>()) outValues[outCount++] = String(v.as<const char*>()).toFloat();
        else if (v.is<bool>()) outValues[outCount++] = v.as<bool>() ? 1.0f : 0.0f;
      }
    } else {
      // Sinon, itérer sur les paires (ordre non garanti)
      for (JsonPair kv : obj) {
        if (outCount >= maxValues) break;
        JsonVariant v = kv.value();
        if (v.is<double>()) outValues[outCount++] = static_cast<float>(v.as<double>());
        else if (v.is<long>()) outValues[outCount++] = static_cast<float>(v.as<long>());
        else if (v.is<const char*>()) outValues[outCount++] = String(v.as<const char*>()).toFloat();
        else if (v.is<bool>()) outValues[outCount++] = v.as<bool>() ? 1.0f : 0.0f;
      }
    }
    return outCount > 0;
  }
  // Valeur simple
  if (root.is<double>()) { outValues[outCount++] = static_cast<float>(root.as<double>()); return true; }
  if (root.is<long>())   { outValues[outCount++] = static_cast<float>(root.as<long>());   return true; }
  if (root.is<const char*>()) { outCount = 1; outValues[0] = String(root.as<const char*>()).toFloat(); return true; }
  if (root.is<bool>()) { outValues[outCount++] = root.as<bool>() ? 1.0f : 0.0f; return true; }
  return false;
}

// Décode un texte brut (une valeur par ligne) en floats
bool parseTextToValues(const String& text, float* outValues, size_t maxValues, size_t& outCount) {
  outCount = 0;
  int start = 0;
  while (outCount < maxValues) {
    int idx = text.indexOf('\\n', start);
    String line = (idx >= 0) ? text.substring(start, idx) : text.substring(start);
    line.trim();
    if (line.length() > 0) {
      outValues[outCount++] = line.toFloat();
    }
    if (idx < 0) break;
    start = idx + 1;
  }
  return outCount > 0;
}

// Récupère les valeurs (HTTP GET + parse JSON/texte)
// Retourne true si succès et remplit outValues dans l'ordre des LABELS (si fournis)
bool getMappedValues(float* outValues, size_t maxValues, size_t& outCount, String& error) {
  outCount = 0;
  error = String();
  HTTPClient http;
  http.begin(ENDPOINT_URL);
  int httpCode = http.GET();
  if (httpCode <= 0) {
    error = String("Erreur HTTP: ") + httpCode;
    http.end();
    return false;
  }

  String payload = http.getString();
  http.end();

  // Essayer JSON d'abord
  StaticJsonDocument<4096> doc;
  DeserializationError err = deserializeJson(doc, payload);
  if (!err) {
    JsonVariant root = doc.containsKey("response") ? doc["response"].as<JsonVariant>() : doc.as<JsonVariant>();
    if (parseJsonToValues(root, outValues, maxValues, outCount)) {
      return true;
    }
  }

  // Sinon, parser comme texte
  if (parseTextToValues(payload, outValues, maxValues, outCount)) {
    return true;
  }

  error = "Réponse vide ou non exploitable";
  return false;
}

void setup() {
  Serial.begin(115200);
  delay(200);

  // Connexion au WiFi
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connexion au WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print('.');
  }
  Serial.println();
  Serial.print("Connecté. IP: ");
  Serial.println(WiFi.localIP());
}

void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi déconnecté, tentative de reconnexion...");
    WiFi.reconnect();
  } else {
    // Récupération simple des valeurs prêtes à l'emploi
    float values[MAX_VALUES];
    size_t count = 0;
    String error;
    if (getMappedValues(values, MAX_VALUES, count, error)) {
      // >>> C'EST ICI QUE VOUS UTILISEZ LES VALEURS REÇUES <<<
      // Exemple: si vous avez sélectionné 1 valeur, elle est dans values[0]
      // - Afficher
      Serial.print("Valeurs reçues ("), Serial.print(count), Serial.println("):");
      for (size_t i = 0; i < count; i++) {
        Serial.print("  ");
        if (i < LABELS_COUNT) { Serial.print(LABELS[i]); Serial.print(": "); }
        Serial.println(values[i]);
      }
      // - Utiliser: ex. piloter une LED, un servo, envoyer vers MQTT, etc.
      //   float temperature = values[0];
      //   if (temperature > 25.0) { /* allumer ventilateur */ }
    } else {
      Serial.print("Erreur: "); Serial.println(error);
    }
    // Attendre avant la prochaine requête
    delay(REFRESH_SECONDS * 1000);
  }
}
`;

            const pre = document.getElementById('arduinoCode');
            if (pre) {
                pre.textContent = code;
            }
        }

        // Fonction pour copier le code Arduino généré
        function copyArduinoCode() {
            const pre = document.getElementById('arduinoCode');
            const code = pre ? pre.textContent : '';
            if (!code || code.includes("s'affichera ici")) {
                showStatus('Aucun code à copier. Générez d\'abord une URL.', 'error');
                return;
            }
            navigator.clipboard.writeText(code).then(() => {
                showStatus('Code Arduino copié dans le presse-papiers !', 'success');
            }).catch(() => {
                showStatus('Impossible de copier le code automatiquement', 'error');
            });
        }

        // Fonction pour sélectionner tous les filtres
        function selectAllFilters() {
            const checkboxes = document.querySelectorAll('.tree-checkbox');
            checkboxes.forEach(checkbox => checkbox.checked = true);
            applyFilters();
        }

        // Fonction pour désélectionner tous les filtres
        function deselectAllFilters() {
            const checkboxes = document.querySelectorAll('.tree-checkbox');
            checkboxes.forEach(checkbox => checkbox.checked = false);
            applyFilters();
        }

        // Fonction pour effacer les données
        function clearData() {
            currentData = null;
            filteredData = null;
            dataMappings = []; // Réinitialiser les mappages
            mappingSystemEnabled = false; // Désactiver par défaut
            const globalToggle = document.getElementById('inputenabled');
            if (globalToggle) {
                globalToggle.checked = false;
                globalToggle.disabled = true;
            }
            document.getElementById('apiUrl').value = '';
            document.getElementById('jsonDisplay').textContent = 'Aucune donnée chargée. Veuillez saisir une URL d\'API et cliquer sur "Récupérer les données".';
            document.getElementById('filtersSection').style.display = 'none';
            document.getElementById('mappingSection').style.display = 'none';
            document.getElementById('esp32Section').style.display = 'none';
            document.getElementById('status').innerHTML = '';
        }

        // Fonction pour rafraîchir les données en préservant les filtres
        async function refreshDataWithFilters() {
            const url = document.getElementById('apiUrl').value.trim();
            if (!url) {
                showStatus('Aucune URL configurée pour le rafraîchissement', 'error');
                return;
            }

            // Sauvegarder les filtres actuellement sélectionnés
            const selectedFilters = Array.from(document.querySelectorAll('.tree-checkbox:checked'))
                .map(checkbox => checkbox.value)
                .filter(value => value && value !== '');

            try {
                // Récupérer les nouvelles données
                const proxyUrl = CORS_PROXY + encodeURIComponent(url);
                const response = await fetch(proxyUrl);
                
                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }

                const data = await response.json();
                currentData = data;
                
                // Régénérer les filtres avec les nouvelles données
                generateFilters(data);
                
                // Restaurer la sélection des filtres
                if (selectedFilters.length > 0) {
                    selectedFilters.forEach(filterPath => {
                        const checkbox = document.querySelector(`.tree-checkbox[value="${filterPath}"]`);
                        if (checkbox) {
                            checkbox.checked = true;
                        }
                    });
                }
                
                // Appliquer les filtres avec les nouvelles données
                applyFilters();
                
                showStatus('Données rafraîchies avec succès !', 'success');
                
            } catch (error) {
                console.error('Erreur lors du rafraîchissement:', error);
                showStatus(`Erreur de rafraîchissement: ${error.message}`, 'error');
            }
        }

        // Fonction pour démarrer le compte à rebours
        function startCountdown(seconds) {
            const countdownElement = document.getElementById('countdown');
            const refreshStatus = document.getElementById('refreshStatus');
            
            let remaining = seconds;
            countdownElement.textContent = remaining;
            refreshStatus.style.display = 'block';
            
            countdownInterval = setInterval(() => {
                remaining--;
                countdownElement.textContent = remaining;
                
                if (remaining <= 0) {
                    clearInterval(countdownInterval);
                    // Le rafraîchissement va se déclencher automatiquement
                }
            }, 1000);
        }

        // Fonction pour arrêter le compte à rebours
        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            document.getElementById('refreshStatus').style.display = 'none';
        }

        // Fonction pour basculer le rafraîchissement automatique
        function toggleAutoRefresh() {
            const interval = parseInt(document.getElementById('refreshInterval').value);
            const button = document.getElementById('autoRefreshBtn');

            if (isAutoRefreshActive) {
                // Arrêter le rafraîchissement
                clearInterval(autoRefreshInterval);
                stopCountdown();
                isAutoRefreshActive = false;
                button.textContent = 'Démarrer';
                button.className = 'btn btn-success';
                showStatus('Rafraîchissement automatique arrêté', 'success');
            } else {
                // Vérifier l'intervalle
                if (interval < 5 || interval > 300) {
                    showStatus('L\'intervalle doit être entre 5 et 300 secondes', 'error');
                    return;
                }
                
                // Vérifier qu'il y a une URL configurée
                const url = document.getElementById('apiUrl').value.trim();
                if (!url) {
                    showStatus('Veuillez d\'abord saisir une URL d\'API', 'error');
                    return;
                }
                
                // Démarrer le rafraîchissement en boucle
                autoRefreshInterval = setInterval(() => {
                    refreshDataWithFilters();
                    startCountdown(interval);
                }, interval * 1000);
                
                isAutoRefreshActive = true;
                button.textContent = 'Arrêter';
                button.className = 'btn btn-secondary';
                showStatus(`🔄 Rafraîchissement automatique activé (${interval}s)`, 'success');
                
                // Faire un premier rafraîchissement immédiat et démarrer le compte à rebours
                refreshDataWithFilters();
                startCountdown(interval);
            }
        }

        // Fonction pour gérer la touche Entrée dans le champ URL
        document.getElementById('apiUrl').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                fetchData();
            }
        });

        // Fonction pour gérer les paramètres URL (mode proxy pour ESP32)
        async function handleProxyMode() {
            const urlParams = new URLSearchParams(window.location.search);
            const shortParam = urlParams.get('s');
            const wantDownload = urlParams.get('download') === '1';
            const proxyUrl = urlParams.get('proxy');
            const filters = urlParams.get('filters');
            
            // Mode URL courte
            if (shortParam) {
                try {
                    // Décoder l'URL courte
                    const config = decodeShortUrl(shortParam);
                    if (!config) {
                        document.body.innerHTML = 'Erreur: URL courte invalide';
                        return true;
                    }
                    
                    const originalUrl = config.url;
                    const filterList = config.filters;
                    const mappings = config.mappings || [];
                    const mappingEnabled = config.mappingEnabled !== undefined ? config.mappingEnabled : true;
                    
                    // Récupérer les données depuis l'API originale
                    const proxyRequestUrl = CORS_PROXY + encodeURIComponent(originalUrl);
                    const response = await fetch(proxyRequestUrl);
                    
                    if (!response.ok) {
                        throw new Error(`Erreur HTTP: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Filtrer les données selon les filtres demandés
                    const filteredData = filterObjectByFields(data, filterList);
                    
                    // Appliquer les mappages temporairement
                    const originalMappings = dataMappings;
                    const originalMappingEnabled = mappingSystemEnabled;
                    dataMappings = mappings;
                    mappingSystemEnabled = mappingEnabled;
                    
                    // Extraire les valeurs en tableau et retourner du JSON
                    const valuesArr = extractValuesArray(filteredData);
                    const payload = valuesArr.length === 1 ? { response: valuesArr[0] } : { response: valuesArr };
                    
                    // Restaurer les mappages originaux
                    dataMappings = originalMappings;
                    mappingSystemEnabled = originalMappingEnabled;
                    
                    // Retourner JSON (texte) ou forcer un téléchargement
                    const jsonText = JSON.stringify(payload);
                    if (wantDownload) {
                        const blob = new Blob([jsonText], { type: 'application/json' });
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = 'response.json';
                        document.body.appendChild(link);
                        link.click();
                        URL.revokeObjectURL(link.href);
                        return true;
                    } else {
                        document.body.innerText = jsonText;
                    }
                    
                } catch (error) {
                    document.body.innerHTML = `Erreur: ${error.message}`;
                }
                return true; // Mode proxy activé
            }
            
            // Mode URL longue (ancien système pour compatibilité)
            if (proxyUrl && filters) {
                try {
                    // Décoder l'URL originale
                    const originalUrl = decodeURIComponent(proxyUrl);
                    const filterList = filters.split(',');
                    
                    // Récupérer les données depuis l'API originale
                    const proxyRequestUrl = CORS_PROXY + encodeURIComponent(originalUrl);
                    const response = await fetch(proxyRequestUrl);
                    
                    if (!response.ok) {
                        throw new Error(`Erreur HTTP: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Filtrer les données selon les filtres demandés
                    const filteredData = filterObjectByFields(data, filterList);
                    
                    // Extraire les valeurs en tableau et retourner du JSON
                    const valuesArr = extractValuesArray(filteredData);
                    const payload = valuesArr.length === 1 ? { response: valuesArr[0] } : { response: valuesArr };
                    const jsonText = JSON.stringify(payload);
                    if (wantDownload) {
                        const blob = new Blob([jsonText], { type: 'application/json' });
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = 'response.json';
                        document.body.appendChild(link);
                        link.click();
                        URL.revokeObjectURL(link.href);
                        return true;
                    } else {
                        document.body.innerText = jsonText;
                    }
                    
                } catch (error) {
                    document.body.innerHTML = `Erreur: ${error.message}`;
                }
                return true; // Mode proxy activé
            }
            return false; // Mode normal
        }

        // Initialisation de l'application
        document.addEventListener('DOMContentLoaded', async function() {
            // Vérifier si on est en mode proxy pour ESP32
            const isProxyMode = await handleProxyMode();
            
            if (!isProxyMode) {
                // Mode normal - interface complète
                // Vous pouvez ajouter une URL d'exemple ici si nécessaire
                // document.getElementById('apiUrl').value = 'https://jsonplaceholder.typicode.com/posts/1';
            }
        });
    </script>
</body>
</html>